<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>拾荒志</title>
  
  <subtitle>虚怀若谷，大智若愚</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://murphypei.github.io/"/>
  <updated>2022-01-12T07:56:27.890Z</updated>
  <id>https://murphypei.github.io/</id>
  
  <author>
    <name>murphypei</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>ssh穿越多个跳板机的连接方法</title>
    <link href="https://murphypei.github.io//blog/2021/12/ssh-proxyjump.html"/>
    <id>https://murphypei.github.io//blog/2021/12/ssh-proxyjump.html</id>
    <published>2021-12-27T02:40:42.000Z</published>
    <updated>2022-01-12T07:56:27.890Z</updated>
    
    <content type="html"><![CDATA[<p>鉴于安全原因，工作需要使用跳板机登录；鉴于服务器环境老旧，我需要在服务器上使用 docker 来搞个开发环境，所以需要有一种方法穿越层层阻隔，让我的 vscode 直接连过去。</p><a id="more"></a><h2 id="ssh-公钥和私钥"><a href="#ssh-公钥和私钥" class="headerlink" title="ssh 公钥和私钥"></a>ssh 公钥和私钥</h2><ul><li>首先搞清楚一些基本关系，一般使用密钥登录，<code>ssh-keygen -t rsa</code> 运行此命令产生公钥私钥（id_rsa 和 id_rsa.pub），一路回车可以不设置保护密码，假设要登录的机器是 server，登录的终端是 client，那么将公钥 id_rsa.pub 的内容记录在 server 的 authorized_keys 中，然后 client 使用私钥 id_rsa 登录。</li><li>每一个被登录的机器都开启的 ssh 服务，并配置了 ssh 密钥登录功能。对于我的需求来说，公司的跳板机和服务器一定是已经配置的，否则无法登录服务器，因此我还需要在 docker 中配置 ssh 密钥登录服务。</li><li>client 设置登录的层层专跳（这是重点）</li></ul><blockquote><p>ssh 相关的文件如果没有特殊说明，都是在 <code>~/.ssh</code> 文件夹中，ssh 服务的配置文件在 <code>/etc/ssh/sshd_config</code> 中。</p></blockquote><h2 id="openssh-的-ProxyJump"><a href="#openssh-的-ProxyJump" class="headerlink" title="openssh 的 ProxyJump"></a>openssh 的 ProxyJump</h2><p>在 openssh7.5 之后（ubuntu18.04），支持 ProxyJump 语句，非常方便。</p><p>假设我们登录路径是这样的：</p><p>client-&gt;jump_server-&gt;server-&gt;dev_docker</p><p>那么 client 的 <code>~/.ssh/config</code> 文件应该如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Host jump</span><br><span class="line">    HostName &lt;jump_server ip&gt;</span><br><span class="line">    Port &lt;jump_server port&gt;</span><br><span class="line">    User &lt;jump_server username&gt;</span><br><span class="line">    IdentityFile &lt;jump_server id_rsa&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Host server</span><br><span class="line">    HostName &lt;server ip&gt;</span><br><span class="line">    Port &lt;server port&gt;</span><br><span class="line">    User &lt;server username&gt;</span><br><span class="line">    IdentityFile &lt;server id_rsa&gt;</span><br><span class="line">    ProxyJump jump</span><br><span class="line"></span><br><span class="line">Host dev_docker</span><br><span class="line">    HostName &lt;dev_docker ip&gt;</span><br><span class="line">    Port &lt;dev_docker port&gt;</span><br><span class="line">    User &lt;dev_docker username&gt;</span><br><span class="line">    IdentityFile &lt;dev_docker id_rsa&gt;</span><br><span class="line">    ProxyJump server</span><br></pre></td></tr></table></figure><p>然后在 client 中，直接使用 <code>ssh dev_docker</code> 命令，ssh 就会一步步登录过去。使用 <code>-v</code> 可以看到每一步的登录过程。</p><p>vscode 会自动读取 config 文件，就可以直接打开 docker 中的文件夹了。真的很方便。</p><p>还有两个比较实用的配置，同样是配置在客户端：</p><ul><li><code>ServerAliveInterval 60</code>：每隔 60s 服务器发送一个包看客户端是否有响应。</li><li><code>ServerAliveCountMax 600</code>：服务器发出请求后客户端没有响应的次数达到一定值，就自动断开，正常情况下，客户端不会不响应。</li></ul><p>这两个配置组合就可以保持 ssh 的长连接了，不用一直手动连接。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;鉴于安全原因，工作需要使用跳板机登录；鉴于服务器环境老旧，我需要在服务器上使用 docker 来搞个开发环境，所以需要有一种方法穿越层层阻隔，让我的 vscode 直接连过去。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://murphypei.github.io/categories/Linux/"/>
    
    
      <category term="linux" scheme="https://murphypei.github.io/tags/linux/"/>
    
      <category term="ssh" scheme="https://murphypei.github.io/tags/ssh/"/>
    
      <category term="proxy" scheme="https://murphypei.github.io/tags/proxy/"/>
    
      <category term="proxyjump" scheme="https://murphypei.github.io/tags/proxyjump/"/>
    
      <category term="jump" scheme="https://murphypei.github.io/tags/jump/"/>
    
  </entry>
  
  <entry>
    <title>C++ 使用 protobuf 踩坑的一次记录</title>
    <link href="https://murphypei.github.io//blog/2021/12/protobuf-debug.html"/>
    <id>https://murphypei.github.io//blog/2021/12/protobuf-debug.html</id>
    <published>2021-12-01T02:40:42.000Z</published>
    <updated>2021-12-08T07:20:18.200Z</updated>
    
    <content type="html"><![CDATA[<p>之前用 protobuf 都比较随意，直到用 protobuf 发布 SDK，遇到了一个坑，恰好遇到了手机的一些问题，导致连环坑。</p><a id="more"></a><h2 id="坑1："><a href="#坑1：" class="headerlink" title="坑1："></a>坑1：</h2><p>这个坑很常见，不仅仅对于我，大概情况如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[libprotobuf ERROR /home/murphy/code/github/protobuf/src/google/protobuf/descriptor_database.cc:58] File already exists <span class="keyword">in</span> database: speech_ai.capt.proto[libprotobuf FATAL /home/murphy/code/github/protobuf/src/google/protobuf/descriptor.cc:1358] CHECK failed: GeneratedDatabase()-&gt;Add(encoded_file_descriptor, size): terminating with uncaught exception of <span class="built_in">type</span> google::protobuf::FatalException: CHECK failed: GeneratedDatabase()-&gt;Add(encoded_file_descriptor, size)</span><br></pre></td></tr></table></figure><p>这个错误原因是因为在两个编译目标（共享库或者可执行文件）中都引入了相同的 <code>*.pb.cc</code> 文件。举个例子：</p><ul><li>我们有个 <code>example.proto</code>，生成了 <code>example.pb.h</code> 和 <code>example.pb.cc</code> 两个文件。</li><li>首先编译一个共享库 <code>A.so</code>，编译的时候需要加入 <code>example.pb.cc</code> 文件，因为其中包含了函数定义。</li><li>编译一个可执行文件 <code>B.out</code>，用来测试 <code>A.so</code> 的接口是否合适，因为 <code>B.out</code> 中也用到了 <code>example.pb.cc</code> 中的函数定义，所以按照常规的想法，也需要加入到其中编译（不然会报 undefined reference 错误），并且 <code>B.out</code> 需要链接 <code>A.so</code>。</li></ul><p>如果这种常规做法，就会报上面类似的错误，我查询的原因可以总结如下（也怪我学艺不精，不太了解 protobuf 的内部机制）：<strong>protobuf 本身有一个 global 的 registry。每个 message type 都需要去那里注册一下，而且不能重复注册</strong>。上述的 <code>Add</code> 错误就是因为注册失败，原因就是因为 <code>A.so</code> 和 <code>B.out</code> 中重复注册了（两份 <code>pb.cc</code> 实现）。</p><ul><li>据说换成 protobuf-lite 就能避免这个问题，但是 Google 官方并没有对此表态。</li></ul><p>最常规的解决办法就是把所有 <code>pb.cc</code> 文件编译成一个共享库 <code>p.so</code>，然后 <code>A.so</code> 和 <code>B.out</code> 都去链接这个共享库。这里需要注意，编译的时候需要设置 <code>visibility=default</code>，把符号都打开（一般 SDK 都会隐藏符号）。</p><h2 id="坑2："><a href="#坑2：" class="headerlink" title="坑2："></a>坑2：</h2><p>这个坑很奇怪，大概如下：我使用 ndk 和 protobuf v3.6.1 编译了 android 的 <code>libprotobuf.so</code>，然后用这个共享库编译 android native 测序程序，运行遇到 Version verification failed，大概如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[libprotobuf FATAL /home/murphy/code/github/protobuf/src/google/protobuf/stubs/common.cc:79] This program was compiled against version 3.0.0 of the Protocol Buffer runtime library, <span class="built_in">which</span> is not compatible with the installed version (3.6.1).  Contact the program author <span class="keyword">for</span> an update.  If you compiled the program yourself, make sure that your headers are from the same version of Protocol Buffers as your link-time library.  (Version verification failed <span class="keyword">in</span> <span class="string">"external/protobuf/src/google/protobuf/any.pb.cc"</span>.)terminating with uncaught exception of <span class="built_in">type</span> google::protobuf::FatalException: This program was compiled against version 3.0.0 of the Protocol Buffer runtime library, <span class="built_in">which</span> is not compatible with the installed version (3.6.1).  Contact the program author <span class="keyword">for</span> an update.  If you compiled the program yourself, make sure that your headers are from the same version of Protocol Buffers as your link-time library.  (Version verification failed <span class="keyword">in</span> <span class="string">"external/protobuf/src/google/protobuf/any.pb.cc"</span>.)</span><br></pre></td></tr></table></figure><p>在 android 使用 gdbserver 调试发现（<a href="https://murphypei.github.io/blog/2021/09/android-gdbserver.html">教程</a>），<code>/system/lib64/</code> 下面有个 <code>protobuf.so</code>，这个 so 的版本是 v3.0.0，但是我们编译的程序理论上是用 v3.6.1 编译的。看上去这里运行的时候，链接的是 v3.6.1，但是 v3.6.1 的符号没有覆盖默认的 v3.0.0 的符号，导致 <code>GOOGLE_PROTOBUF_VERSION</code> 这个符号变成了 <code>3000000</code> 而不是 <code>3006001</code>，所以就会失败。</p><p>这个问题没有找到解决方案，我换了一个测试手机，没有复现这个问题，所以猜测可能是之前的测试手机有一些问题，如果遇到这个问题，建议换个测试手机试试。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前用 protobuf 都比较随意，直到用 protobuf 发布 SDK，遇到了一个坑，恰好遇到了手机的一些问题，导致连环坑。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="registry" scheme="https://murphypei.github.io/tags/registry/"/>
    
      <category term="protobuf" scheme="https://murphypei.github.io/tags/protobuf/"/>
    
      <category term="共享库" scheme="https://murphypei.github.io/tags/%E5%85%B1%E4%BA%AB%E5%BA%93/"/>
    
      <category term="protoc" scheme="https://murphypei.github.io/tags/protoc/"/>
    
  </entry>
  
  <entry>
    <title>使用 vscode 调试 C++ 程序</title>
    <link href="https://murphypei.github.io//blog/2021/11/vscode-cpp.html"/>
    <id>https://murphypei.github.io//blog/2021/11/vscode-cpp.html</id>
    <published>2021-11-04T03:00:28.000Z</published>
    <updated>2021-11-05T03:47:57.290Z</updated>
    
    <content type="html"><![CDATA[<p>vscode 远程比 clion 好用太多了，就是 C++ 调试功能不如 clion，不过简单配置一下，也可以实现单步调试，比简陋的 GDB 还是好用多了。</p><a id="more"></a><p>下面的配置是我的某个项目的配置，仅仅作为参考和自己的记录，因为国内大部分的教程都只写单独的文件，没啥参考价值。</p><h3 id="c-cpp-properties-json"><a href="#c-cpp-properties-json" class="headerlink" title="c_cpp_properties.json"></a>c_cpp_properties.json</h3><p>这个文件主要是配置一些头文件路径，不过现在 vscode 对于头文件的支持还是不太行，配置了还有很多波浪线，头疼。</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"configurations"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"Linux"</span>,</span><br><span class="line">            <span class="attr">"includePath"</span>: [</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;/**"</span>,</span><br><span class="line">                <span class="string">"$&#123;workspaceFolder&#125;/build"</span></span><br><span class="line">            ],</span><br><span class="line">            <span class="attr">"defines"</span>: [],</span><br><span class="line">            <span class="attr">"configurationProvider"</span>: <span class="string">"ms-vscode.cmake-tools"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    <span class="attr">"version"</span>: <span class="number">4</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="tasks-json"><a href="#tasks-json" class="headerlink" title="tasks.json"></a>tasks.json</h3><p>这个文件是执行真正的任务，主要是编译任务。以前我以为只支持 g++ 命令（坑爹的国内教程），后来想通了，这个文件其实就是执行 linux 命令，你可以放 cmake、make 甚至编译脚本的命令，我通常喜欢写一个编译脚本来编译。</p><p>下面的例子，cmake 和 make 执行编译，build 通过脚本编译。make 任务可以不需要 cmake 重新生成（关闭 dependsOn），方便快速增量编译。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="attr">"version"</span>: <span class="string">"2.0.0"</span>,</span><br><span class="line">    <span class="attr">"tasks"</span>: [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"cmake"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"options"</span>: &#123;</span><br><span class="line">                <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;/build"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"cmake -DCMAKE_BUILD_TYPE=Debug -DBUILD_ANDROID=OFF -DBUILD_UNIT_TESTS=ON -DBUILD_SHARED_LIBS=ON -DCUDA_ENABLE=OFF .. "</span></span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"make"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"options"</span>: &#123;</span><br><span class="line">                <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;/build"</span></span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"make -j8"</span>,</span><br><span class="line">            // "dependsOn": [</span><br><span class="line">            //     "cmake"</span><br><span class="line">            // ],</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"label"</span>: <span class="string">"build"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"shell"</span>,</span><br><span class="line">            <span class="attr">"command"</span>: <span class="string">"source $&#123;workspaceFolder&#125;/linux.sh"</span></span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="launch-json"><a href="#launch-json" class="headerlink" title="launch.json"></a>launch.json</h3><p>用 GDB 执行可执行文件，没啥说的，注意 preLaunchTask 根据需要选择（tasks.json 中配置的 build 彻底重新编译，make 只编译改动的头文件）。</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    // 使用 IntelliSense 了解相关属性。 </span><br><span class="line">    // 悬停以查看现有属性的描述。</span><br><span class="line">    // 欲了解更多信息，请访问: https://go.microsoft.com/fwlink/?linkid=830387</span><br><span class="line">    "version": "0.2.0",</span><br><span class="line">    "configurations": [</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="attr">"name"</span>: <span class="string">"capt_test"</span>,</span><br><span class="line">            <span class="attr">"type"</span>: <span class="string">"cppdbg"</span>,</span><br><span class="line">            <span class="attr">"request"</span>: <span class="string">"launch"</span>,</span><br><span class="line">            <span class="attr">"program"</span>: <span class="string">"$&#123;workspaceFolder&#125;/build/capt_test"</span>,</span><br><span class="line">            <span class="attr">"args"</span>: [],</span><br><span class="line">            <span class="attr">"stopAtEntry"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"cwd"</span>: <span class="string">"$&#123;workspaceFolder&#125;"</span>,</span><br><span class="line">            <span class="attr">"environment"</span>: [],</span><br><span class="line">            <span class="attr">"externalConsole"</span>: <span class="literal">false</span>,</span><br><span class="line">            <span class="attr">"MIMode"</span>: <span class="string">"gdb"</span>,</span><br><span class="line">            <span class="attr">"setupCommands"</span>: [</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="attr">"description"</span>: <span class="string">"为 gdb 启用整齐打印"</span>,</span><br><span class="line">                    <span class="attr">"text"</span>: <span class="string">"-enable-pretty-printing"</span>,</span><br><span class="line">                    <span class="attr">"ignoreFailures"</span>: <span class="literal">true</span></span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            // "preLaunchTask": "make"</span><br><span class="line">            "preLaunchTask": "build"</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;vscode 远程比 clion 好用太多了，就是 C++ 调试功能不如 clion，不过简单配置一下，也可以实现单步调试，比简陋的 GDB 还是好用多了。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="c++" scheme="https://murphypei.github.io/tags/c/"/>
    
      <category term="vscode" scheme="https://murphypei.github.io/tags/vscode/"/>
    
      <category term="tasks" scheme="https://murphypei.github.io/tags/tasks/"/>
    
      <category term="launch" scheme="https://murphypei.github.io/tags/launch/"/>
    
      <category term="c_cpp_properties" scheme="https://murphypei.github.io/tags/c-cpp-properties/"/>
    
  </entry>
  
  <entry>
    <title>语音识别 FBank 和 MFCC 特征</title>
    <link href="https://murphypei.github.io//blog/2021/10/asr-fbank-mfcc.html"/>
    <id>https://murphypei.github.io//blog/2021/10/asr-fbank-mfcc.html</id>
    <published>2021-10-13T04:21:07.000Z</published>
    <updated>2021-11-05T03:47:57.290Z</updated>
    
    <content type="html"><![CDATA[<p>ASR 流程中，音频特征提取是第一步。和 CV 不同，图片本身的 RGB 数值就是一种特征，但是音频本身无法被用于分析，常常是将一段音频提取 FBank 和 MFCC 特征然后作为模型的输入。</p><a id="more"></a><p>语音参数提取特征的步骤：预增强-&gt;分帧-&gt;加窗-&gt;添加噪声-&gt;FFT-&gt;Mel滤波-&gt;对数运算-&gt;DCT。其中 FFT 和 DCT 是快速傅里叶变换和离散余弦变换。</p><h2 id="音频预处理"><a href="#音频预处理" class="headerlink" title="音频预处理"></a>音频预处理</h2><h3 id="预增强（Pre-Emphasis）"><a href="#预增强（Pre-Emphasis）" class="headerlink" title="预增强（Pre-Emphasis）"></a>预增强（Pre-Emphasis）</h3><p>预增强一般是数字语音信号处理的第一步。语音信号往往会有频谱倾斜（Spectral Tilt）现象，即高频部分的幅度会比低频部分的小，预增强在这里就是起到一个平衡频谱的作用，增大高频部分的幅度。它使用如下的一阶滤波器来实现：</p><script type="math/tex; mode=display">y(t) = x(t) - \alpha * x(t-1), 0.95 < \alpha < 0.99</script><h3 id="分帧（Framing）"><a href="#分帧（Framing）" class="headerlink" title="分帧（Framing）"></a>分帧（Framing）</h3><p>输入的音频信号是一段连续，一般流式的有几百毫秒，非流式的有几秒或者更长，需要将信号分成短时帧。做这一步的原因是：信号中的频率会随时间变化（不稳定的），一些信号处理算法（比如傅里叶变换）通常希望信号是稳定，也就是说对整个信号进行处理是没有意义的，因为信号的频率轮廓会随着时间的推移而丢失。为了避免这种情况，需要对信号进行分帧处理，认为每一帧之内的信号是短时不变的。一般设置帧长取 20ms~40ms，相邻帧之间 50\%（+/-10\%）的覆盖。对于 ASR 而言，通常取帧长为 25ms，帧移为 10ms（不重叠部分）。</p><h3 id="加窗"><a href="#加窗" class="headerlink" title="加窗"></a>加窗</h3><p>在分帧之后，通常需要对每帧的信号进行加窗处理。目的是让帧两端平滑地衰减，这样可以降低后续傅里叶变换后旁瓣的强度，取得更高质量的频谱。常用的窗有：矩形窗、汉明（Hamming）窗、汉宁窗（Hanning），以汉明窗为例，其窗函数为：</p><script type="math/tex; mode=display">w(n)=0.54-0.46cos(\frac{2\pi n}{N-1}), 0\le n\le N-1</script><h3 id="随机添加噪声（可选）"><a href="#随机添加噪声（可选）" class="headerlink" title="随机添加噪声（可选）"></a>随机添加噪声（可选）</h3><p>有时候我们需要进行数据增强，会手动合成一些音频。某些人工合成的音频可能会造成一些数字错误，诸如 underflow 或者 overflow。 这种情况下，通过添加随机噪声可以解决这一类问题。公式如下：</p><script type="math/tex; mode=display">s(n)=s(n)+q∗rand()</script><p>$q$ 用于控制添加噪声的强度，$rand()$ 产生 $[-1.0, 1.0)$ 的随机数。</p><p>注意：Kaldi 中是在分帧之后的下一步添加随机噪声</p><h2 id="特征提取"><a href="#特征提取" class="headerlink" title="特征提取"></a>特征提取</h2><p>人耳对声音频谱的响应是非线性的，经验表明：如果我们能够设计一种前端处理算法，以类似于人耳的方式对音频进行处理，可以提高语音识别的性能。FilterBank就是这样的一种算法。FBank 特征提取要在预处理之后进行，这时语音已经分帧，我们需要逐帧提取 FBank 特征。</p><h3 id="快速傅里叶变换（FFT）"><a href="#快速傅里叶变换（FFT）" class="headerlink" title="快速傅里叶变换（FFT）"></a>快速傅里叶变换（FFT）</h3><p>我们分帧之后得到的仍然是时域信号，为了提取 FBank 特征，首先需要<strong>将时域信号转换为频域信号</strong>。傅里叶变换可以将信号从时域转到频域。傅里叶变换可以分为连续傅里叶变换和离散傅里叶变换，因为我们用的是数字音频（而非模拟音频），所以我们用到的是离散傅里叶变换。数学公式如下：</p><script type="math/tex; mode=display">X(k)=\sum_{j=1}^{N} x(j)w_{N}^{(j-1)(k-1)}</script><p>对每一帧加窗后的音频信号做 N 点的 FFT 变换，也称短时傅里叶变换（STFT），N通常取256或512，然后用如下的公式<strong>计算能量谱</strong>：</p><script type="math/tex; mode=display">P=\frac{|FFT(x_i)|^2}{N}</script><h3 id="FBank-Filter-Banks-特征"><a href="#FBank-Filter-Banks-特征" class="headerlink" title="FBank(Filter Banks)特征"></a>FBank(Filter Banks)特征</h3><p>经过上面的步骤之后，在能量谱上应用 Mel 滤波器组，就能提取到FBank特征。</p><p>在介绍Mel滤波器组之前，先介绍一下 Mel 刻度，这是一个能模拟人耳接收声音规律的刻度，人耳在接收声音时呈现非线性状态，对高频的更不敏感，因此 Mel 刻度在低频区分辨度较高，在高频区分辨度较低，与频率之间的换算关系为：</p><script type="math/tex; mode=display">m=2595log_{10}(1+\frac{f}{700})</script><p>Mel 滤波器组就是一系列的三角形滤波器，通常有 40 个或 80 个，在中心频率点响应值为 1，在两边的滤波器中心点线性衰减到 0，如下图：</p><p><img src="/images/posts/asr/fbank_mfcc/mel.jpg" alt></p><p>具体公式就不写了，网上可查。</p><p>在能量谱上应用 Mel 滤波器组，其公式为：</p><script type="math/tex; mode=display">Y_{t}(m)=\sum_{k=1}^{N} H_{m}(k)|X_t(k)|^2</script><p>其中，$k$ 表示 FFT 变换后的编号，$m$ 表示 Mel 滤波器的编号。</p><h3 id="MFCC-Mel-frequency-Cepstral-Coefficients-特征"><a href="#MFCC-Mel-frequency-Cepstral-Coefficients-特征" class="headerlink" title="MFCC(Mel-frequency Cepstral Coefficients)特征"></a>MFCC(Mel-frequency Cepstral Coefficients)特征</h3><p>前面提取到的 FBank 特征，往往是高度相关的。因此可以继续用 DCT 变换，将这些相关的滤波器组系数进行压缩。对于 ASR 来说，通常取 2~13 维，扔掉的信息里面包含滤波器组系数快速变化部分，这些细节信息在 ASR 任务上可能没有帮助。</p><p><strong>DCT 变换其实是逆傅里叶变换的等价替代</strong>：</p><script type="math/tex; mode=display">y_t(n)=\sum_{m=0}^{M-1}log(Y_{t}(m))cos(n(m+0.5)\frac{\pi }{M}), n=0,...,J</script><p>所以 MFCC 名字里面有倒谱（Cepstral）。</p><p>一般对于ASR来说，对 MFCC 进行一个正弦提升（sinusoidal liftering）操作，可以提升在噪声信号中最后的识别率：</p><script type="math/tex; mode=display">MFCC_i^{'}=w_iMFCC_i</script><script type="math/tex; mode=display">w_i=\frac{D}{2}sin(\frac{\pi * i}{D})</script><p>从公式看，猜测原因可能是对频谱做一个平滑，如果 $D$ 取值较大时，会加重高频部分，使得噪声被弱化。</p><h3 id="python-实现"><a href="#python-实现" class="headerlink" title="python 实现"></a>python 实现</h3><p><a href="https://gist.github.com/murphypei/dcae63c9de780586a70a89603bd0f2c2" target="_blank" rel="noopener">https://gist.github.com/murphypei/dcae63c9de780586a70a89603bd0f2c2</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ASR 流程中，音频特征提取是第一步。和 CV 不同，图片本身的 RGB 数值就是一种特征，但是音频本身无法被用于分析，常常是将一段音频提取 FBank 和 MFCC 特征然后作为模型的输入。&lt;/p&gt;
    
    </summary>
    
      <category term="ASR" scheme="https://murphypei.github.io/categories/ASR/"/>
    
    
      <category term="fbank" scheme="https://murphypei.github.io/tags/fbank/"/>
    
      <category term="mfcc" scheme="https://murphypei.github.io/tags/mfcc/"/>
    
      <category term="asr" scheme="https://murphypei.github.io/tags/asr/"/>
    
      <category term="fft" scheme="https://murphypei.github.io/tags/fft/"/>
    
  </entry>
  
  <entry>
    <title>使用 gdbserver 调试 Android Native 程序</title>
    <link href="https://murphypei.github.io//blog/2021/09/android-gdbserver.html"/>
    <id>https://murphypei.github.io//blog/2021/09/android-gdbserver.html</id>
    <published>2021-09-06T09:40:10.000Z</published>
    <updated>2021-12-08T07:20:18.200Z</updated>
    
    <content type="html"><![CDATA[<p>使用 Android NDK 编译得到 Android native program，可以直接 push 到手机上运行，但是没办法直接用 gdb debug。</p><a id="more"></a><p>为此，我们需要使用 gdbserver，也就是 gdb 远程调试功能。原理就不讲了，我自己尝试的过程中发现网上写的教程都是相互转载的，乱七八糟，不知所云。本文写原理（谷歌可查），仅仅记录下我已经确认可行的调试过程。</p><ol><li>首先，把 <code>$NDK/prebuilt/android-arm64/gdbserver/gdbserver</code> 以及要调试的程序 push 到手机上（任意文件夹）。</li><li>在手机上启动 gdbserver。<code>gdbserver :9090 &lt;exec&gt;</code>。其中 <code>:9090</code> 表示 gdbserver 监听手机的 9090 端口。会显示 <code>Listening on port 9090</code> 类似信息。如果有本地 lib，记得设置 <code>LD_LIBRARY_PATH</code> 环境变量。</li><li>设置端口转发。<code>adb forward tcp:9090 tcp:9090</code>，表示将本地 9090 端口转发到手机的 9090 端口。</li><li>本地启动 gdb。<code>$NDK/prebuilt/linux-x86_64/bin/gdb</code>。进入 gdb 调试页面。</li><li>设置调试对象。<code>target remote :9090</code>。调试本地的 9090 端口，同时也是手机的 9090 端口，也就是 gdbserver，连接成功之后， gdbserver 那边会显示 <code>Remote debugging from host 127.0.0.1</code> 字样。</li></ol><p>Android gdbserver 和 Linux gdb 有一些命令不太一样，但是很多还是相同的。启动程序不用 r，用 continue。</p><p>用 vscode 也可以，把上述流程弄到 vscode 的 task.json 中就行，只是觉得更麻烦了，所以没必要。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用 Android NDK 编译得到 Android native program，可以直接 push 到手机上运行，但是没办法直接用 gdb debug。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++" scheme="https://murphypei.github.io/tags/C/"/>
    
      <category term="gdbserver" scheme="https://murphypei.github.io/tags/gdbserver/"/>
    
      <category term="gdb remote" scheme="https://murphypei.github.io/tags/gdb-remote/"/>
    
      <category term="android" scheme="https://murphypei.github.io/tags/android/"/>
    
      <category term="native" scheme="https://murphypei.github.io/tags/native/"/>
    
  </entry>
  
  <entry>
    <title>LRU 缓存算法</title>
    <link href="https://murphypei.github.io//blog/2021/07/lru.html"/>
    <id>https://murphypei.github.io//blog/2021/07/lru.html</id>
    <published>2021-07-07T10:49:24.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>看到 lc 上有一道题是设计 LRU 算法，简单了解了一下作为记录。</p><a id="more"></a><p>LRU 算法实际上是让你设计数据结构：首先要接收一个 capacity 参数作为缓存的最大容量，然后实现两个 API，一个是 <code>put(key, val)</code> 方法存入键值对，另一个是 <code>get(key)</code> 方法获取 key 对应的 val，如果 key 不存在则返回 -1。</p><p>注意哦，get 和 put 方法必须都是 O(1) 的时间复杂度，我们举个具体例子来看看 LRU 算法怎么工作。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* 缓存容量为 2 */</span></span><br><span class="line">LRUCache cache = <span class="keyword">new</span> LRUCache(<span class="number">2</span>);</span><br><span class="line"><span class="comment">// 你可以把 cache 理解成一个队列</span></span><br><span class="line"><span class="comment">// 假设左边是队头，右边是队尾</span></span><br><span class="line"><span class="comment">// 最近使用的排在队头，久未使用的排在队尾</span></span><br><span class="line"><span class="comment">// 圆括号表示键值对 (key, val)</span></span><br><span class="line"></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">1</span>);</span><br><span class="line"><span class="comment">// cache = [(1, 1)]</span></span><br><span class="line">cache.put(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// cache = [(2, 2), (1, 1)]</span></span><br><span class="line">cache.get(<span class="number">1</span>);       <span class="comment">// 返回 1</span></span><br><span class="line"><span class="comment">// cache = [(1, 1), (2, 2)]</span></span><br><span class="line"><span class="comment">// 解释：因为最近访问了键 1，所以提前至队头</span></span><br><span class="line"><span class="comment">// 返回键 1 对应的值 1</span></span><br><span class="line">cache.put(<span class="number">3</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// cache = [(3, 3), (1, 1)]</span></span><br><span class="line"><span class="comment">// 解释：缓存容量已满，需要删除内容空出位置</span></span><br><span class="line"><span class="comment">// 优先删除久未使用的数据，也就是队尾的数据</span></span><br><span class="line"><span class="comment">// 然后把新的数据插入队头</span></span><br><span class="line">cache.get(<span class="number">2</span>);       <span class="comment">// 返回 -1 (未找到)</span></span><br><span class="line"><span class="comment">// cache = [(3, 3), (1, 1)]</span></span><br><span class="line"><span class="comment">// 解释：cache 中不存在键为 2 的数据</span></span><br><span class="line">cache.put(<span class="number">1</span>, <span class="number">4</span>);    </span><br><span class="line"><span class="comment">// cache = [(1, 4), (3, 3)]</span></span><br><span class="line"><span class="comment">// 解释：键 1 已存在，把原始值 1 覆盖为 4</span></span><br><span class="line"><span class="comment">// 不要忘了也要将键值对提前到队头</span></span><br></pre></td></tr></table></figure><p>我们分析一下这个实现要求。查询和插入都需要 O(1)，那不用说了，只能是哈希表。C++ 可以用 <code>std::unordered_map</code> 实现。再看这个缓存满的时候，需要删除最久为使用的，所以每个元素必须在每次操作之后保持其顺序。这个实现比较灵活了，但是因为涉及 O(1) 插入，所以 <code>std::list</code> 是最合适的。总结：</p><ul><li>通过 key 查询和插入 O(1)，哈希表，但是哈希表无顺序。</li><li>链表可保持顺序，插入和删除 O(1)，但是查询慢。</li></ul><p>因此就需要将二者结合使用，也就是<strong>哈希链表</strong>。具体实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unordered_map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LRUCache</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    LRUCache(<span class="keyword">int</span> capacity) : capacity(capacity) &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">get</span><span class="params">(<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hashTable.find(key) == hashTable.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 更新到表头</span></span><br><span class="line">            <span class="keyword">auto</span> iter = hashTable[key]; <span class="comment">// 找到对应地址</span></span><br><span class="line">            cache.splice(cache.begin(), cache, iter); <span class="comment">// 移动到表头</span></span><br><span class="line">            <span class="keyword">return</span> cache.begin()-&gt;second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">put</span><span class="params">(<span class="keyword">int</span> key, <span class="keyword">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (hashTable.find(key) == hashTable.end())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (cache.size() == capacity)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">// 删除表尾</span></span><br><span class="line">                hashTable.erase(cache.back().first);</span><br><span class="line">                cache.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 在表头添加</span></span><br><span class="line">            cache.push_front(<span class="built_in">std</span>::make_pair(key, value));</span><br><span class="line">            hashTable[key] = cache.begin();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> iter    = hashTable[key];</span><br><span class="line">            iter-&gt;second = value; <span class="comment">// 更新元素</span></span><br><span class="line">            cache.splice(cache.begin(), cache, iter); <span class="comment">// 移动到表头</span></span><br><span class="line">            hashTable[key] = cache.begin(); <span class="comment">// 更新地址</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;::iterator&gt; hashTable;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="built_in">std</span>::pair&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt;&gt;                                    cache; <span class="comment">// key, value</span></span><br><span class="line">    <span class="keyword">int</span>                                                               capacity = <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>具体操作就很简单了，无非是哈希表和链表的查询、删除和移动。主要看成员变量 <code>hashTable</code> 和 <code>cache</code>。<code>cache</code> 保存的就是实际数据的 key 和 value，<code>hashTable</code> 保存链表的 key 和地址。</p><p>通过哈希表，我们能够弥补链表查询慢的特点，直取链表中 key 所在节点的位置。而通过链表，我们可以很容易的维持每次操作后元素的顺序。这里有一个需要注意的，<strong>链表中必须也存有 key</strong>，因为哈希表删除是需要 key 的，链表如果只能提供 value，哈希表将无法删除。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;看到 lc 上有一道题是设计 LRU 算法，简单了解了一下作为记录。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://murphypei.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://murphypei.github.io/tags/algorithm/"/>
    
      <category term="LRU" scheme="https://murphypei.github.io/tags/LRU/"/>
    
      <category term="缓存" scheme="https://murphypei.github.io/tags/%E7%BC%93%E5%AD%98/"/>
    
      <category term="哈希表" scheme="https://murphypei.github.io/tags/%E5%93%88%E5%B8%8C%E8%A1%A8/"/>
    
      <category term="链表" scheme="https://murphypei.github.io/tags/%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>Floyd 环形算法</title>
    <link href="https://murphypei.github.io//blog/2021/07/floyd-circle.html"/>
    <id>https://murphypei.github.io//blog/2021/07/floyd-circle.html</id>
    <published>2021-07-06T03:01:04.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>题目来自 leetcode 142. 环形链表 II，判断一个链表是否有环，如果有，找到环形起点。</p><a id="more"></a><p>首先是链表判断是否有环，刷过题的都知道快慢指针，快指针一次移动两步，慢指针一次移动一步，如果两个指针最终相遇则有环，如果快指针到达终点，则无环。</p><p>计算环形起点一般使用 Floyld 算法。接上面，两指针相遇之后，将慢指针移动到链表头部，然后两个指针每次移动一步，再次相遇就是环形起点。这个算法简洁明了，非常简单，但是需要思考一下证明方法。</p><p>假设链表头到环形起点的距离是 $m$，也就是非环部分；链表环长度为 $n$；相遇的时候距离环形起点的位置为 $k$。</p><p>慢指针相遇的时候移动距离：$m + A \cdot n + k$，快指针相遇的时候移动距离：$m + B \cdot n + k$。</p><p>因为快指针是慢指针的二倍，因此：</p><script type="math/tex; mode=display">S = (B - A) \cdot n = m + B \cdot n + k</script><p>$B$ 和 $A$ 都是正整数，因此<strong>相遇时慢指针移动的总长度是环形的整倍数</strong>，快指针是慢指针的 2 倍，因此快指针走过的总长度也是环形的整倍数。</p><p>现在把慢指针移动到链表头部，然后移动 $m$ 步，到达了环形的起点，慢指针移动 $S + m$，快指针移动 $2 \cdot S + m$，$S$ 是环形长度的整倍数，因此快指针此时也一定是到达了环形的起点，两个指针相遇。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;题目来自 leetcode 142. 环形链表 II，判断一个链表是否有环，如果有，找到环形起点。&lt;/p&gt;
    
    </summary>
    
      <category term="Algorithm" scheme="https://murphypei.github.io/categories/Algorithm/"/>
    
    
      <category term="algorithm" scheme="https://murphypei.github.io/tags/algorithm/"/>
    
      <category term="floyld" scheme="https://murphypei.github.io/tags/floyld/"/>
    
      <category term="环形算法" scheme="https://murphypei.github.io/tags/%E7%8E%AF%E5%BD%A2%E7%AE%97%E6%B3%95/"/>
    
      <category term="快慢指针" scheme="https://murphypei.github.io/tags/%E5%BF%AB%E6%85%A2%E6%8C%87%E9%92%88/"/>
    
      <category term="弗洛伊德" scheme="https://murphypei.github.io/tags/%E5%BC%97%E6%B4%9B%E4%BC%8A%E5%BE%B7/"/>
    
  </entry>
  
  <entry>
    <title>Go 中 context 的使用方式</title>
    <link href="https://murphypei.github.io//blog/2021/06/go-context.html"/>
    <id>https://murphypei.github.io//blog/2021/06/go-context.html</id>
    <published>2021-06-06T18:45:28.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>context 是 go 中控制协程的一种比较方便的方式。</p><a id="more"></a><h3 id="Select-Chan"><a href="#Select-Chan" class="headerlink" title="Select + Chan"></a>Select + Chan</h3><p>我们都知道一个 goroutine 启动后，我们是无法控制他的，大部分情况是等待它自己结束，那么如果这个 goroutine 是一个不会自己结束的后台 goroutine 呢？比如监控等，会一直运行的。</p><p>这种情况下比较笨的办法是全局变量，其他地方通过修改这个变量完成结束通知，然后后台 goroutine 不停的检查这个变量，如果发现被通知关闭了，就自我结束。这种方式首先我们要保证这个变量在多线程下的安全，基于此，有一种经典的处理方式：<code>chan</code> + <code>select</code> 。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">stop := <span class="built_in">make</span>(<span class="keyword">chan</span> <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-stop:    <span class="comment">// 收到了停滞信号</span></span><br><span class="line">fmt.Println(<span class="string">"监控退出，停止了..."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"goroutine监控中..."</span>)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"可以了，通知监控停止"</span>)</span><br><span class="line">stop&lt;- <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>这里还有一个额外的知识，go 中通道的接收是有阻塞和非阻塞的（发送只有阻塞），这里 select 中的 case 语句接收通道数据其实是非阻塞的。非阻塞接收通道数据的 CPU 消耗较高，但是可以获取是否通道中有数据的状态。但是当 case 上读一个通道时，如果这个通道是 nil，则该 case 永远阻塞</p></blockquote><p>例子中我们定义一个 stop 的 chan，通知他结束后台 goroutine。实现也非常简单，在后台 goroutine 中，使用 select 判断 stop 是否可以接收到值，如果可以接收到，就表示可以退出停止了；如果没有接收到，就会执行 default 里的监控逻辑，继续监控，只到收到 stop 的通知。</p><p>有了以上的逻辑，我们就可以在其他 goroutine 中，给 stop chan 发送值了，例子中是在 main goroutine 中发送的，控制让这个监控的 goroutine 结束。</p><p>发送了 <code>stop&lt;-true</code> 结束的指令后，我这里使用 <code>time.Sleep(5 * time.Second)</code> 故意停顿5秒来检测我们结束监控 goroutine 是否成功。如果成功的话，不会再有 <code>goroutine监控中...</code> 的输出了；如果没有成功，监控 goroutine 就会继续打印 <code>goroutine监控中...</code> 输出。</p><p>这种 chan+select 的方式，是比较优雅的结束一个 goroutine 的方式，不过这种方式也有局限性，如果有很多 goroutine 都需要控制结束怎么办呢？如果这些 goroutine 又衍生了其他更多的 goroutine 怎么办呢？如果一层层的无穷尽的 goroutine 呢？这就非常复杂了，即使我们定义很多 chan 也很难解决这个问题，因为 goroutine 的关系链就导致了这种场景非常复杂。</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>上面说的这种场景是存在的，比如一个网络请求 Request，每个 Request 都需要开启一个 goroutine 做一些事情，这些 goroutine 又可能会开启其他的 goroutine。所以我们需要一种可以跟踪 goroutine 的方案，才可以达到控制他们的目的，这就是 Go 语言为我们提供的 Context，称之为上下文非常贴切，它就是 goroutine 的上下文。</p><p>下面我们就使用 Go Context 重写上面的示例。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(<span class="string">"监控退出，停止了..."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(<span class="string">"goroutine监控中..."</span>)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;(ctx)</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"可以了，通知监控停止"</span>)</span><br><span class="line">cancel()</span><br><span class="line"><span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重写也很简单，把之前使用 select+chan 控制的协程改为 Context 控制即可：</p><p><code>context.Background()</code> 返回一个空的 Context，这个空的 Context 一般用于整个 Context 树的根节点。然后我们使用 <code>context.WithCancel(parent)</code> 函数，创建一个可取消的子 Context，然后当作参数传给 goroutine 使用，这样就可以使用这个子 Context 跟踪这个 goroutine。</p><p>在 goroutine 中，使用 select 调用 <code>&lt;-ctx.Done()</code> 判断是否要结束，如果接受到值的话，就可以返回结束 goroutine 了；如果接收不到，就会继续进行监控。</p><p>那么 Context 是如何发送结束指令的呢？这就是示例中的 <code>cancel</code> 函数啦，它是我们调用 <code>context.WithCancel(parent)</code> 函数生成子 Context 的时候返回的，第二个返回值就是这个取消函数，它是 <code>CancelFunc</code> 类型的。我们调用它就可以发出取消指令，然后我们的监控 goroutine 就会收到信号，就会返回结束。</p><h3 id="Context-控制多个-goroutine"><a href="#Context-控制多个-goroutine" class="headerlink" title="Context 控制多个 goroutine"></a>Context 控制多个 goroutine</h3><p>使用 Context 控制一个 goroutine 的例子如上，非常简单，下面我们看看控制多个 goroutine 的例子，其实也比较简单。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="keyword">go</span> watch(ctx,<span class="string">"【监控1】"</span>)</span><br><span class="line"><span class="keyword">go</span> watch(ctx,<span class="string">"【监控2】"</span>)</span><br><span class="line"><span class="keyword">go</span> watch(ctx,<span class="string">"【监控3】"</span>)</span><br><span class="line"></span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"可以了，通知监控停止"</span>)</span><br><span class="line">cancel()</span><br><span class="line"><span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context, name <span class="keyword">string</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line">fmt.Println(name,<span class="string">"监控退出，停止了..."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">fmt.Println(name,<span class="string">"goroutine监控中..."</span>)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>示例中启动了 3 个监控 goroutine 进行不断的监控，每一个都使用了 Context 进行跟踪，<strong>当我们使用 cancel 函数通知取消时，这 3 个 goroutine 都会被结束</strong>。这就是 Context 的控制能力，它就像一个控制器一样，按下开关后，<strong>所有基于这个 Context 或者衍生的子 Context 都会收到通知</strong>，这时就可以进行清理操作了，最终释放 goroutine，这就优雅的解决了 goroutine 启动后不可控的问题。</p><h3 id="Context-接口"><a href="#Context-接口" class="headerlink" title="Context 接口"></a>Context 接口</h3><p>Context 的接口定义的比较简洁，我们看下这个接口的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> Context <span class="keyword">interface</span> &#123;</span><br><span class="line">Deadline() (deadline time.Time, ok <span class="keyword">bool</span>)</span><br><span class="line"></span><br><span class="line">Done() &lt;-<span class="keyword">chan</span> <span class="keyword">struct</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Err() error</span><br><span class="line"></span><br><span class="line">Value(key <span class="keyword">interface</span>&#123;&#125;) <span class="keyword">interface</span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个接口共有 4 个方法，了解这些方法的意思非常重要，这样我们才可以更好的使用他们。</p><p><code>Deadline</code> 方法是获取设置的截止时间的意思，第一个返回式是截止时间，到了这个时间点，Context 会自动发起取消请求；第二个返回值 <code>ok</code> 表示是否设置截止时间，如果没有设置时间，当需要取消的时候，需要调用取消函数进行取消。</p><p><code>Done</code> 方法返回一个只读的 chan，类型为 struct{}，我们在 goroutine 中，如果该方法返回的 chan 可以读取，则意味着 parent context 已经发起了取消请求，我们通过 Done 方法收到这个信号后，就应该做清理操作，然后退出 goroutine，释放资源。</p><p><code>Err</code> 方法返回取消的错误原因，因为什么 Context 被取消。</p><p><code>Value</code> 方法获取该 Context 上绑定的值，是一个键值对，所以要通过一个 Key 才可以获取对应的值，这个值一般是线程安全的。</p><p>以上四个方法中常用的就是 <code>Done</code> 了，如果 Context 取消的时候，我们就可以得到一个关闭的 chan，关闭的 chan 是可以读取的，所以<strong>只要 <code>ctx.Done()</code> 可以读取的时候，就意味着收到 Context 取消的信号了</strong>，以下是这个方法的经典用法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Stream</span><span class="params">(ctx context.Context, out <span class="keyword">chan</span>&lt;- Value)</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line">v, err := DoSomething(ctx)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line"><span class="keyword">return</span> err</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="keyword">return</span> ctx.Err()</span><br><span class="line"><span class="keyword">case</span> out &lt;- v:</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Context 接口并不需要我们实现，Go 内置已经帮我们实现了 2 个，我们代码中最开始都是以这两个内置的作为最顶层的 partent context，衍生出更多的子 Context。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> (</span><br><span class="line">background = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">todo       = <span class="built_in">new</span>(emptyCtx)</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">Background</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> background</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">TODO</span><span class="params">()</span> <span class="title">Context</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> todo</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个是 <code>Background</code>，主要用于 main 函数、初始化以及测试代码中，作为 Context 这个树结构的最顶层的 Context，也就是根 Context。</p><p>一个是 <code>TODO</code>，它目前还不知道具体的使用场景，如果我们不知道该使用什么 Context 的时候，可以使用这个。</p><p>他们两个本质上都是 emptyCtx 结构体类型，是一个不可取消，没有设置截止时间，没有携带任何值的 Context。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> emptyCtx <span class="keyword">int</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Deadline</span><span class="params">()</span> <span class="params">(deadline time.Time, ok <span class="keyword">bool</span>)</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Done</span><span class="params">()</span> &lt;-<span class="title">chan</span> <span class="title">struct</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Err</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(*emptyCtx)</span> <span class="title">Value</span><span class="params">(key <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Context-的继承衍生"><a href="#Context-的继承衍生" class="headerlink" title="Context 的继承衍生"></a>Context 的继承衍生</h3><p>有了如上的根 Context，那么是如何衍生更多的子 Context 的呢？这就要靠 context 包为我们提供的 With 系列的函数了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">WithCancel</span><span class="params">(parent Context)</span> <span class="params">(ctx Context, cancel CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithDeadline</span><span class="params">(parent Context, deadline time.Time)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithTimeout</span><span class="params">(parent Context, timeout time.Duration)</span> <span class="params">(Context, CancelFunc)</span></span></span><br><span class="line"><span class="function"><span class="title">func</span> <span class="title">WithValue</span><span class="params">(parent Context, key, val <span class="keyword">interface</span>&#123;&#125;)</span> <span class="title">Context</span></span></span><br></pre></td></tr></table></figure><p>这四个 With 函数，接收的都有一个 <code>partent</code> 参数，就是父 Context，我们要基于这个父 Context 创建出子 Context 的意思，这种方式可以理解为子 Context 对父 Context 的继承，也可以理解为基于父 Context 的衍生。</p><p>通过这些函数，就创建了一颗 Context 树，树的每个节点都可以有任意多个子节点，节点层级可以有任意多个。每个父节点可以控制自己所有的子节点。</p><ul><li><code>WithCancel</code> 函数，传递一个父 Context 作为参数，返回子 Context，以及一个取消函数用来取消 Context。 </li><li><code>WithDeadline</code> 函数，和 <code>WithCancel</code> 差不多，它会多传递一个截止时间参数，意味着到了这个时间点，会自动取消 Context，当然我们也可以不等到这个时候，可以提前通过取消函数进行取消。</li><li><code>WithTimeout</code> 和 <code>WithDeadline</code> 基本上一样，这个表示是超时自动取消，是多少时间后自动取消 Context 的意思。</li><li><code>WithValue</code> 函数和取消 Context 无关，它是为了生成一个绑定了一个键值对数据的 Context，这个绑定的数据可以通过 Context.Value方法访问到，后面我们会专门讲。</li></ul><p>大家可能留意到，前三个函数都返回一个取消函数 CancelFunc，这是一个函数类型，它的定义非常简单。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">type</span> CancelFunc <span class="function"><span class="keyword">func</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><p>这就是取消函数的类型，该函数可以取消一个 Context，以及这个节点 Context 下所有的所有的 Context，不管有多少层级。</p><h3 id="WithValue-传递元数据"><a href="#WithValue-传递元数据" class="headerlink" title="WithValue 传递元数据"></a>WithValue 传递元数据</h3><p>通过 Context 我们也可以传递一些必须的元数据，这些数据会附加在 Context 上以供使用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> key <span class="keyword">string</span>=<span class="string">"name"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">ctx, cancel := context.WithCancel(context.Background())</span><br><span class="line"><span class="comment">//附加值</span></span><br><span class="line">valueCtx:=context.WithValue(ctx,key,<span class="string">"【监控1】"</span>)</span><br><span class="line"><span class="keyword">go</span> watch(valueCtx)</span><br><span class="line">time.Sleep(<span class="number">10</span> * time.Second)</span><br><span class="line">fmt.Println(<span class="string">"可以了，通知监控停止"</span>)</span><br><span class="line">cancel()</span><br><span class="line"><span class="comment">//为了检测监控过是否停止，如果没有监控输出，就表示停止了</span></span><br><span class="line">time.Sleep(<span class="number">5</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">watch</span><span class="params">(ctx context.Context)</span></span> &#123;</span><br><span class="line"><span class="keyword">for</span> &#123;</span><br><span class="line"><span class="keyword">select</span> &#123;</span><br><span class="line"><span class="keyword">case</span> &lt;-ctx.Done():</span><br><span class="line"><span class="comment">//取出值</span></span><br><span class="line">fmt.Println(ctx.Value(key),<span class="string">"监控退出，停止了..."</span>)</span><br><span class="line"><span class="keyword">return</span></span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line"><span class="comment">//取出值</span></span><br><span class="line">fmt.Println(ctx.Value(key),<span class="string">"goroutine监控中..."</span>)</span><br><span class="line">time.Sleep(<span class="number">2</span> * time.Second)</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在前面的例子，我们通过传递参数的方式，把 <code>name</code> 的值传递给监控函数。在这个例子里，我们实现一样的效果，但是通过的是 Context 的 Value 的方式。</p><p>我们可以使用 <code>context.WithValue</code> 方法附加一对 K-V 的键值对，这里 Key 必须是等价性的，也就是具有可比性；Value 值要是线程安全的。</p><p>这样我们就生成了一个新的 Context，这个新的 Context 带有这个键值对，在使用的时候，可以通过 Value 方法读取 <code>ctx.Value(key)</code>。</p><p>记住，使用 WithValue 传值，一般是必须的值，不要什么值都传递。</p><h3 id="Context-使用原则"><a href="#Context-使用原则" class="headerlink" title="Context 使用原则"></a>Context 使用原则</h3><ul><li>不要把 Context 放在结构体中，要以参数的方式传递。</li><li>以 Context 作为参数的函数方法，应该把 Context 作为第一个参数，放在第一位。</li><li>给一个函数方法传递 Context 的时候，不要传递 nil，如果不知道传递什么，就使用 <code>context.TODO</code>。</li><li>Context 的 Value 相关方法应该传递必须的数据，不要什么数据都使用这个传递。</li><li>Context 是线程安全的，可以放心的在多个 goroutine 中传递。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;context 是 go 中控制协程的一种比较方便的方式。&lt;/p&gt;
    
    </summary>
    
      <category term="Go" scheme="https://murphypei.github.io/categories/Go/"/>
    
    
      <category term="go" scheme="https://murphypei.github.io/tags/go/"/>
    
      <category term="context" scheme="https://murphypei.github.io/tags/context/"/>
    
      <category term="goroutine" scheme="https://murphypei.github.io/tags/goroutine/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch distributed barrier 引发的陷阱</title>
    <link href="https://murphypei.github.io//blog/2021/05/torch-barrier-trap.html"/>
    <id>https://murphypei.github.io//blog/2021/05/torch-barrier-trap.html</id>
    <published>2021-05-20T07:17:19.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>Pytorch 中 <code>torch.distributed.barrier</code> 函数通常用于分布式进程同步，但是使用也存在一个陷阱。</p><a id="more"></a><p>记录一个最近使用 Pytorch 分布式遇到的一个问题。</p><p>熟悉 Pytorch 的同学一定知道 <code>torch.distributed.barrier</code> 是用于不同进程间的同步，其原理很简单，就是<strong>每个进程进入这个函数后都会被阻塞，当所有进程都进入这个函数后，阻塞解除</strong>，继续向下执行。废话不多说，直接说重点：<strong>所有进程都执行到这一步</strong>。也就是说如果有些代码是某个进程单独执行，并且不小心包含了这条语句，那么这个进程陷入无限等待。</p><p>直接看我的<strong>错误例子</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">train_dataloader = create_dataloader(rank, ...)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> rank <span class="keyword">in</span> [<span class="number">-1</span>, <span class="number">0</span>]:</span><br><span class="line">    val_dataloader = create_dataloader(rank, ...)</span><br></pre></td></tr></table></figure><p><code>create_dataloader</code> 内部：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">create_dataloader</span><span class="params">(rank, ...)</span>:</span></span><br><span class="line">    <span class="keyword">with</span> torch_distributed_zero_first(rank):</span><br><span class="line">        dataset = Dataset(...)</span><br><span class="line">    </span><br><span class="line">    dataloader = foo(dataset)</span><br><span class="line">    <span class="keyword">return</span> dataloader</span><br></pre></td></tr></table></figure></p><p><code>torch_distributed_zero_first(rank)</code> 是一个 contextmanager，其用法就是用 <code>@contextmanager</code> 语法糖修饰一个生成器，使其能够按照 <code>with ...</code> 形式执行。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">torch_distributed_zero_first</span><span class="params">(rank)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> rank <span class="keyword">not</span> <span class="keyword">in</span> [<span class="number">-1</span>, <span class="number">0</span>]:</span><br><span class="line">        torch.distributed.barrier()</span><br><span class="line">    <span class="keyword">yield</span></span><br><span class="line">    <span class="keyword">if</span> rank == <span class="number">0</span>:</span><br><span class="line">        torch.distributed.barrier()</span><br></pre></td></tr></table></figure></p><p>contextmanager，其用法就是用执行顺序是：</p><ol><li>首先<code>with</code> 语句先执行生成器内部代码，遇到 <code>yield</code> 之后返回（如果有返回值则就是 <code>with ... as ...</code> 中 as 的值）。</li><li>继续执行 <code>with</code> 嵌套的语句（如上就是创建 Dataset），执行完毕回到生成器。</li><li>执行 <code>yield</code> 后面的语句。</li></ol><p>首先说明一下，使用 <code>torch_distributed_zero_first</code> 的目的是执行创建 dataloader 的时候，期望主进程能够先执行，这样可以创建一些缓存之类的文件，让后续进程直接读取缓存，加快顺序，这是出发点。我们看一下运行原理：首先 <code>create_dataloader</code> 中 <code>with torch_distributed_zero_first(rank):</code> 调用会让除了主进程以外的其他进程进入阻塞，只有主进程会继续在 <code>yield</code> 执行的时候返回，执行嵌套语句，创建 Dataset，然后再次进入生成器，调用 barrier。这时候所有进程进入了 barrier 函数，因此所有一起被唤醒，继续向下执行。因此这样确保所有进程中主进程最先执行了嵌套语句。</p><p>弄明白了上述的工作原理，再看 <code>val_dataloader</code> 的创建过程，其问题出在<strong>只有主进程执行了这个调用</strong>。因此按照上述分析，主进程创建完 Dataset 之后，被阻塞，此时其他进程并未被阻塞，因此主进程陷入无限阻塞（后续如果恰好其他进程执行到 barrier 或许可以解除）。因此这里应该传入 <code>rank=-1</code>，跳过 if 后面的 barrier。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Pytorch 中 &lt;code&gt;torch.distributed.barrier&lt;/code&gt; 函数通常用于分布式进程同步，但是使用也存在一个陷阱。&lt;/p&gt;
    
    </summary>
    
      <category term="PyTorch" scheme="https://murphypei.github.io/categories/PyTorch/"/>
    
    
      <category term="pytorch" scheme="https://murphypei.github.io/tags/pytorch/"/>
    
      <category term="distribute" scheme="https://murphypei.github.io/tags/distribute/"/>
    
      <category term="barrier" scheme="https://murphypei.github.io/tags/barrier/"/>
    
      <category term="DDP" scheme="https://murphypei.github.io/tags/DDP/"/>
    
  </entry>
  
  <entry>
    <title>C++ sizeof 总结</title>
    <link href="https://murphypei.github.io//blog/2021/03/cpp-sizeof.html"/>
    <id>https://murphypei.github.io//blog/2021/03/cpp-sizeof.html</id>
    <published>2021-03-09T09:02:13.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>sizeof 是很老的知识，从笔记移到博文中。</p><a id="more"></a><p>计算机取数据最低一个字节，基本都是双字，因此如果数据没有对齐，有时候一个数可能分布在多个字节中，内存对齐是为了加快计算机的取数速度，否则就得多花指令周期。关于内存对齐，可以参考<a href="https://murphypei.github.io/blog/2020/04/memory-align.html">浅谈内存对齐</a>。下面是 sizeof 的一些对齐知识。</p><h4 id="对齐基本规则"><a href="#对齐基本规则" class="headerlink" title="对齐基本规则"></a>对齐基本规则</h4><ul><li>结构体变量的首地址能够被其最宽基本类型成员的大小所整除。</li><li>结构体每个成员相对于结构体首地址的偏移量（offset）都是成员大小的整数倍，如有需要编译器会在成员之间加上填充字节（internal adding）。</li><li>结构体的总大小为结构体最宽基本类型成员大小的整数倍，如有需要编译器会在最末一个成员之后加上填充字节（trailing padding）。</li></ul><h4 id="sizeof-类或者结构体"><a href="#sizeof-类或者结构体" class="headerlink" title="sizeof 类或者结构体"></a>sizeof 类或者结构体</h4><ul><li>sizeof 结构体以及类的实例是同一结果，sizeof 类本质上就是计算类的实例大小。</li><li>sizeof 一个空类（或者空结构体），结果是 1。空类，没有任何成员变量或函数，即没有存储任何内容，所以大小为 0，但是由于空类仍然可以实例化，一个类能够实例化，编译器就需给它分配内存空间，来指示类实例的地址，所以编译器就为类默认添加了一个隐藏的字节。</li><li>sizeof 只考虑类的成员变量，不需要考虑成员函数，<strong>但是虚函数会增加虚表指针的空间（虚表指针在对象内存的首位置）。</strong></li><li>类的静态成员变量不计入 sizeof 大小。</li><li>子类继承了父类的私有成员，子类虽然不能访问，但是 sizeof 仍需要计算这一部分。<ul><li>子类继承一个空类，sizeof 则大小为子类的大小（子类也是空类，则 sizeof 为 1）</li></ul></li><li>当上述的类<strong>虚继承</strong>一个空类（是不是空都无所谓），那么虚继承的子类中需要<strong>添加一个虚基类指针</strong>（虚继承就是类似虚函数的实现来实现基类共享）</li><li>多继承中如果多个父类有虚函数，则会有多个虚函数表，子类自己定义的虚函数不会生成虚函数表，单继承时并入父类的虚表，多继承时并入继承的第一个父类的虚表中。</li></ul><h4 id="sizeof-数组"><a href="#sizeof-数组" class="headerlink" title="sizeof 数组"></a>sizeof 数组</h4><ul><li>sizeof 数组和指针是不一样的，sizeof 计算的是数组的大小。</li><li>C 风格的 char 数组，如果不指定数组的长度，计算结果是字符个数 +1，包含 \0 的结束位。    </li></ul><h4 id="sizeof-union"><a href="#sizeof-union" class="headerlink" title="sizeof union"></a>sizeof union</h4><p>联合体的内存是重叠的，则 sizeof 就是最大数据成员的大小。</p><h4 id="利用-sizeof-获取结构体某个成员的偏移量"><a href="#利用-sizeof-获取结构体某个成员的偏移量" class="headerlink" title="利用 sizeof 获取结构体某个成员的偏移量"></a>利用 sizeof 获取结构体某个成员的偏移量</h4><p>思路：将 0 地址转换为结构体的指针，然后获取成员的地址即偏移量</p><p><code>#define offsetof(s,m) (size_t)&amp;(((s *)0)-&gt;m)</code></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;sizeof 是很老的知识，从笔记移到博文中。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++" scheme="https://murphypei.github.io/tags/C/"/>
    
      <category term="sizeof" scheme="https://murphypei.github.io/tags/sizeof/"/>
    
  </entry>
  
  <entry>
    <title>C++ 中 malloc 和 new 的区别</title>
    <link href="https://murphypei.github.io//blog/2021/03/malloc-new-diff.html"/>
    <id>https://murphypei.github.io//blog/2021/03/malloc-new-diff.html</id>
    <published>2021-03-09T08:58:07.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>C++ 中 malloc 和 new 都能开辟内存，这篇笔记记录 C++ 中 malloc 和 new 开辟新内存的区别。</p><a id="more"></a><h4 id="申请内存的位置不同："><a href="#申请内存的位置不同：" class="headerlink" title="申请内存的位置不同："></a>申请内存的位置不同：</h4><ul><li><strong>new 操作符从自由存储区（free store）上为对象动态分配内存空间</strong>，自由存储区是 C++ 基于 new 操作符的一个抽象概念，凡是通过 new 操作符进行内存申请，该内存即为自由存储区。自由存储区不仅可以是堆，还可以是静态存储区，这都    看 operator new 在哪里为对象分配内存。</li><li><strong>malloc 函数从堆上动态分配内存</strong>。</li></ul><h4 id="返回类型的安全性"><a href="#返回类型的安全性" class="headerlink" title="返回类型的安全性"></a>返回类型的安全性</h4><ul><li>new 操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故 new 是符合类型安全性的操作符。</li><li>malloc 内存分配成功则是返回 void 指针 ，需要通过强制类型转换将 void 指针转换成我们需要的类型。</li></ul><h4 id="内存分配失败时的返回值"><a href="#内存分配失败时的返回值" class="headerlink" title="内存分配失败时的返回值"></a>内存分配失败时的返回值</h4><ul><li>new 内存分配失败时，会抛出 bac_alloc 异常，它不会返回 NULL。</li><li>malloc 分配失败时返回 NULL。</li></ul><h4 id="分配内存大小"><a href="#分配内存大小" class="headerlink" title="分配内存大小"></a>分配内存大小</h4><ul><li>使用 new 操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。</li><li>malloc 则需要明确指出所需内存的尺寸。</li></ul><h4 id="是否调用构造函数-析构函数"><a href="#是否调用构造函数-析构函数" class="headerlink" title="是否调用构造函数/析构函数"></a>是否调用构造函数/析构函数</h4><ul><li>使用 new 操作符来分配对象内存时会经历三个步骤：<ol><li>调用 operator new 函数（对于数组是 operator new[]）分配一块足够大的，原始的，未命名的内存空间以便存储特定类型的对象。</li><li>编译器运行相应的构造函数以构造对象，并为其传入初值。</li><li>对象构造完成后，返回一个指向该对象的指针。</li></ol></li><li>使用 delete 操作符来释放对象内存时会经历两个步骤：<ol><li>调用对象的析构函数。</li><li>编译器调用operator delete(或operator delete[])函数释放内存空间。</li></ol></li><li>malloc不会调用构造函数，free也不会调用析构函数。</li></ul><h4 id="对于数组的处理"><a href="#对于数组的处理" class="headerlink" title="对于数组的处理"></a>对于数组的处理</h4><ul><li>C++ 提供了 new[] 与 delete[] 来专门处理数组类型的分配。new 对数组的支持体现在它会分别调用构造函数函数初始化每一个数组元素，释放对象时为每个对象调用析构函数。</li><li>注意 delete[] 要与 new[] 配套使用，不然会找出数组对象部分释放的现象，造成内存泄漏。</li><li>malloc 并知道你在这块内存上要放的数组还是啥别的东西，反正它就给你一块原始的内存，在给你个内存的地址就完事。所以如果要动态分配一个数组的内存，还需要我们手动自定数组的大小</li></ul><h4 id="是否可以被重载"><a href="#是否可以被重载" class="headerlink" title="是否可以被重载"></a>是否可以被重载</h4><p>opeartor new /operator delete 可以被重载。注意，new 表达式和 operator new 是不同的，前者调用后者，严格来说，我们区分的是 new 表达式和 malloc 表达式，所以应该都不支持重载。</p><h4 id="是否支持内存扩充"><a href="#是否支持内存扩充" class="headerlink" title="是否支持内存扩充"></a>是否支持内存扩充</h4><ul><li>new 不支持内存扩充</li><li>malloc 在分配内存后，如果内存不足，可以<strong>使用 realloc 进行内存重新分配</strong>，实现扩充。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;C++ 中 malloc 和 new 都能开辟内存，这篇笔记记录 C++ 中 malloc 和 new 开辟新内存的区别。&lt;/p&gt;
    
    </summary>
    
      <category term="C/C++" scheme="https://murphypei.github.io/categories/C-C/"/>
    
    
      <category term="C++" scheme="https://murphypei.github.io/tags/C/"/>
    
      <category term="delete" scheme="https://murphypei.github.io/tags/delete/"/>
    
      <category term="malloc" scheme="https://murphypei.github.io/tags/malloc/"/>
    
      <category term="new" scheme="https://murphypei.github.io/tags/new/"/>
    
      <category term="operator new" scheme="https://murphypei.github.io/tags/operator-new/"/>
    
      <category term="free" scheme="https://murphypei.github.io/tags/free/"/>
    
  </entry>
  
  <entry>
    <title>Git 不同平台下软链接问题</title>
    <link href="https://murphypei.github.io//blog/2021/03/git-symlink.html"/>
    <id>https://murphypei.github.io//blog/2021/03/git-symlink.html</id>
    <published>2021-03-03T07:05:06.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>早就听说不同平台软链接兼容问题很大，最近遇上了，记录一下这个问题。</p><a id="more"></a><h3 id="问题场景"><a href="#问题场景" class="headerlink" title="问题场景"></a>问题场景</h3><p>问题场景很常见也很简单。有一个 C++ 项目，在 Linux 下开发，引用了一些第三方库，比如 opencv，其中的 lib 有些是软链接的形式。在 windows 下拉取仓库之后，发现软链接失效了（不影响 windows 平台本身的运行）。我使用 clion 将 windows 的代码同步到远程开发机，则编译无法进行，文件格式错误。原因在于不同操作系统使用的文件系统不同，因此软链接失效了。不同文件系统软链接不兼容的问题，网上自己找找一大堆，实现不同，没啥说的。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><p>现在的 git 都支持了软链接的兼容处理，安装的时候有个 symlink 选项，勾上即可。另外需要在 clone 的时候处理：</p><ul><li>首先，使用<strong>以管理员方式</strong>打开 git bash，因为 windows 创建软链接需要管理员权限。</li><li>clone 的时候必须<strong>明确指定</strong>兼容软链接。<code>git clone -c core.symlinks=true ...</code>。在 亲测 <code>.gitconfig</code> 中设置无效。</li></ul><p>这样 clone 下来的仓库里，之前的软链接就变成了 windows 系统中的快捷方式。但是这种快捷方式通过 clion 同步到 Linux 中就是自动的软链接，非常 nice。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>windows 下的 git bash 可以通过创造快捷方式的办法兼容 Linux 下的软链接，并且同步到 Linux 中还能保持软链接。</li><li>clion 的远程开发落后 vscode 一个段位，本质就是 rsync 文件同步和 ssh 执行一些命令，因此当遇到这种 windows 和 Linux 中不兼容的文件，这种简单的同步方式必然 GG。</li></ul><p>为了解决这个问题顺便测试了最新的 vscode 的 C/C++ 和 cmake 插件，已经解决之前的 includePath 和跳转提示问题，加上强大的 remote 和 git，我觉得 vscode 取代 clion 已经是近在咫尺了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;早就听说不同平台软链接兼容问题很大，最近遇上了，记录一下这个问题。&lt;/p&gt;
    
    </summary>
    
      <category term="Git" scheme="https://murphypei.github.io/categories/Git/"/>
    
    
      <category term="git" scheme="https://murphypei.github.io/tags/git/"/>
    
      <category term="symlink" scheme="https://murphypei.github.io/tags/symlink/"/>
    
      <category term="linux" scheme="https://murphypei.github.io/tags/linux/"/>
    
      <category term="windows" scheme="https://murphypei.github.io/tags/windows/"/>
    
  </entry>
  
  <entry>
    <title>OpenGL 渲染管线简介</title>
    <link href="https://murphypei.github.io//blog/2021/02/opengl-render.html"/>
    <id>https://murphypei.github.io//blog/2021/02/opengl-render.html</id>
    <published>2021-02-20T03:25:17.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>最近在学习 OpenGL 渲染特效的东西，需要补充一些基础知识，遇到不错的介绍文章，整理摘录。</p><a id="more"></a><h2 id="图形渲染管线"><a href="#图形渲染管线" class="headerlink" title="图形渲染管线"></a>图形渲染管线</h2><p>在 OpenGL 的世界里，任何事物是处于 3D 空间中的，而屏幕和窗口显示的却是 2D，所以 OpenGL 干的事情基本就是 <strong>把3D坐标转变为适应屏幕的2D像素</strong>。</p><p>3D 坐标转为 2D 坐标的处理过程是由 OpenGL 的<strong>图形渲染管线</strong>管理的，图形渲染管线可以被划分为两个主要部分：</p><blockquote><p>图形渲染管线(Graphics Pipeline)，大多译为<strong>管线</strong>，实际上指的是一堆原始图形数据途经一个输送管道，期间经过各种变化处理最终出现在屏幕的过程。</p></blockquote><ol><li>第一部分把你的 3D 坐标转换为 2D 坐标。</li><li>第二部分是把 2D 坐标转变为实际的有颜色的像素。</li></ol><blockquote><p>另外，<strong>2D 坐标</strong>和<strong>像素</strong>也是不同的概念，2D 坐标精确表示一个点在 2D 空间中的<strong>位置</strong>，而 2D 像素是这个点的<strong>近似值</strong>，2D 像素受到你的屏幕/窗口分辨率的限制。<br>简单来说就是坐标是一个包含无限个数值的集合，像素则是极小的有限个区域。</p></blockquote><p>现在我们就简单地讲讲图形渲染管线内，数据处理的过程：</p><ul><li>管线接受一组 3D 坐标，然后把它们转变为你屏幕上的有色 2D 像素输出。</li><li>管线可以被划分为几个阶段，每个阶段将会把前一个阶段的输出作为输入。</li><li>所有这些阶段都是高度专门化的（它们都有一个特定的函数），并且<strong>很容易并行执行</strong>。</li><li>由于它们具有并行执行的特性，当今大多数显卡都有成千上万的小处理核心，它们在GPU上为每一个（渲染管线）阶段运行各自的小程序，从而在图形渲染管线中快速处理你的数据，这些小程序叫做<strong>着色器(Shader)</strong>。<ul><li>着色器有好几种，其中有些着色器允许开发者自己配置，以更细致地控制管线中的特定部分。</li><li>着色器运行在GPU上。</li><li>OpenGL 着色器是用 OpenGL 着色器语言 (OpenGL Shading Language 即 GLSL) 写成的。</li></ul></li></ul><p>关于着色器我们之后再讨论，回到管线，下面是一个图形渲染管线的每个阶段的抽象展示，其中蓝色的是我们可以注入自定义的着色器的部分。</p><p><img src="/images/posts/opengl/render_pipeline/opengl-render.png" alt></p><p>如你所见，图形渲染管线包含很多部分，每个部分都将在转换顶点数据到最终像素这一过程中处理各自特定的阶段，我们下面会概括性地解释一下渲染管线的每个部分，从而对图形渲染管线的工作方式有个大概了解。</p><h3 id="图元"><a href="#图元" class="headerlink" title="图元"></a>图元</h3><p>我们需要先简单了解下图元。</p><p>为了让 OpenGL 知道我们的坐标和颜色值构成的到底是什么，你需要去指定这些数据所表示的渲染类型，比如说：传入坐标等数据后，你想让 OpenGL 把这些数据渲染成一系列的点？一系列的三角形？还是线？以上要给 OpenGL 的这些信息就叫<strong>图元(Primitive)</strong>，任何一个绘制指令的调用都将是<strong>把图元传递给 OpenGL</strong>。这是其中的几种：<code>GL_POINTS</code>、<code>GL_TRIANGLES</code>、<code>GL_LINE_STRIP</code>（点，三角形，线）。</p><blockquote><p>这里我理解三角形就是代表面，因为如果我们想渲染一块区域，就应该使用三角形。</p></blockquote><p>接下来正式进入渲染管线的介绍。这也是初学者比较头晕的部分，本文将分开一步步具体分析。</p><h3 id="渲染管线流程"><a href="#渲染管线流程" class="headerlink" title="渲染管线流程"></a>渲染管线流程</h3><p>现在假设我们的目的就是画出一个三角形。下面我们对渲染管线中每个流程一一说明。</p><p>首先，我们要以数组的形式传递 3 个 3D 坐标作为图形渲染管线的输入，用来表示一个三角形，<strong>一个 3D 坐标的数据的集合就是一个顶点(Vertex)</strong>；这个数组就是一系列顶点的集合，我们叫他<strong>顶点数据(Vertex Data)</strong>（简单起见，我们先假定每个顶点只由一个3D位置和一些颜色值组成）。</p><blockquote><p>这里再次强调，OpenGL 是 3D 的，因此内部表示的坐标都是 3D 坐标，哪怕我们想画的是 2D 图形。另外展示的都是屏幕像素，是 2D 的，因此渲染管线必须包含坐标处理。这里要切记。</p></blockquote><p><img src="/images/posts/opengl/render_pipeline/vertex-data.png" alt></p><p>顶点数据会进入<strong>顶点着色器(Vertex Shader)</strong>，它把一个单独的顶点作为输入，顶点着色器主要的目的是把输入的 3D 坐标转为另一种 3D 坐标（之后会解释），同时对顶点属性进行一些基本处理。</p><p><img src="/images/posts/opengl/render_pipeline/vertex-shader.png" alt></p><p>顶点着色器输出的所有顶点会进入<strong>图元装配(Primitive Assembly)</strong>阶段，它将所有的点装配成<strong>指定图元的形状</strong>（这里的例子中是一个三角形，如果是 <code>GL_POINTS</code>，那么就是一个个的点）。</p><p><img src="/images/posts/opengl/render_pipeline/shape-assembly.png" alt></p><p>图元装配阶段的输出会传递给<strong>几何着色器(Geometry Shader)</strong>，几何着色器把图元形式的一系列顶点的集合作为输入，它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状，在这个例子里，它生成了另一个三角形。</p><p><img src="/images/posts/opengl/render_pipeline/geometry-shader.png" alt></p><p>几何着色器的输出会被传入<strong>光栅化阶段(Rasterization Stage)</strong>，这里它会把图元映射为最终屏幕上相应的像素，生成供片段着色器(Fragment Shader)使用的片段(Fragment)（<strong>OpenGL 的一个片段是 OpenGL 渲染一个像素所需的所有数据</strong>）。但在片段着色器运行之前还会执行裁切(Clipping)，裁切会丢弃超出你的视图以外的所有像素，用来提升执行效率。</p><p><img src="/images/posts/opengl/render_pipeline/rasterization.png" alt></p><p>输出的片段(Fragment)将会传入片段着色器(Fragment Shader)，它主要作用是计算一个像素的最终颜色，这也是所有 OpenGL 高级效果产生的地方，通常，片段着色器包含 3D 场景的数据（比如光照、阴影、光的颜色等等），这些数据可被用来计算最终像素的颜色。</p><p><img src="/images/posts/opengl/render_pipeline/fragment-shader.png" alt></p><p>在所有对应颜色值确定以后，最终的对象将会被传到最后一个阶段，我们叫做 Alpha 测试和混合(Blending)阶段。这个阶段检测片段的对应的深度（和模板(Stencil)）值，用以判断这个像素是在前面还是后面，决定是否丢弃。这个阶段也会检查alpha 值（alpha值 定义了一个物体的透明度）并对物体进行混合(Blend)。所以，即使在片段着色器中计算出来了一个像素输出的颜色，在渲染多个三角形的时候最后的像素颜色也可能完全不同。</p><p><img src="/images/posts/opengl/render_pipeline/test-blending.png" alt></p><p>可以看到，图形渲染管线非常复杂，它包含很多可配置的部分。<strong>但其实对于大多数场合，我们只需要配置顶点和片段着色器就行了</strong>（几何着色器是可选的，通常使用它默认的着色器就行了）。</p><p>在现代 OpenGL 中，我们也必须定义<strong>至少一个顶点着色器和一个片段着色器</strong>（GPU 中没有默认的顶点/片段着色器），因此刚开始学习的时候可能会非常困难，在你能够渲染自己的第一个三角形之前，已经需要了解一大堆知识了。</p><h3 id="管线小结"><a href="#管线小结" class="headerlink" title="管线小结"></a>管线小结</h3><p>我们再梳理一次渲染管线的流程：</p><p><img src="/images/posts/opengl/render_pipeline/opengl-render.png" alt></p><ol><li>首先，我们以数组的形式传递 3 个 3D 坐标作为图形渲染管线的输入，这个数组叫做<strong>顶点数据(Vertex Data)</strong>，是<strong>一系列顶点的集合</strong>。</li><li><strong>顶点着色器(Vertex Shader)</strong> 把顶点的 3D 坐标转为另一种 3D 坐标，同时允许我们对顶点属性进行一些基本处理。</li><li><strong>图元装配(Primitive Assembly)</strong> 将所有的点装配成指定图元的形状。</li><li><strong>几何着色器(Geometry Shader)</strong> 它可以通过产生新顶点构造出新的（或是其它的）图元来生成其他形状，在我们这里，它生成了另一个三角形。</li><li><strong>光栅化阶段(Rasterization Stage)</strong> 会把图元映射为最终屏幕上相应的像素，生成片段(Fragment)，并执行裁切(Clipping)，丢弃超出你的视图以外的所有像素提升效率。</li><li><strong>片段着色器(Fragment Shader)</strong> 计算一个像素的最终颜色。</li><li><strong>Alpha测试和混合(Blending)</strong> 阶段检测片段的对应的深度（和模板(Stencil)）值，决定是否丢弃；这个阶段也会检查alpha值并对物体进行混合(Blend)。</li></ol><p>都理解了之后，我们将尝试渲染一个三角形。</p><h2 id="顶点输入"><a href="#顶点输入" class="headerlink" title="顶点输入"></a>顶点输入</h2><p>先记住以下三个概念：</p><ul><li>顶点数组对象：Vertex Array Object，<strong>VAO</strong></li><li>顶点缓冲对象：Vertex Buffer Object，<strong>VBO</strong></li><li>索引缓冲对象：Element Buffer Object，<strong>EBO</strong> 或 Index Buffer Object，<strong>IBO</strong></li></ul><p>就如管线的流程，想要让 OpenGL 绘制图形，我们必须先给 OpenGL 喂一些顶点数据，<strong>顶点输入</strong>实际上步骤并不少，过程并不简单。</p><p>首先 OpenGL 是一个 3D 图形库，所以我们在 OpenGL 中指定的所有坐标都是 3D 坐标（x，y，z）。然后，OpenGL 不是简单地把所有的 3D 坐标变换为屏幕上的 2D 像素：仅当 3D 坐标在 3 个轴（x、y、z）上都为 <strong>-1.0 到 1.0</strong> 的范围内时才处理它，而所有在所谓的<strong>标准化设备坐标(Normalized DeviceCoordinates)</strong>范围内的坐标才会最终呈现在屏幕上。</p><h4 id="标准化设备坐标-Normalized-Device-Coordinates-NDC"><a href="#标准化设备坐标-Normalized-Device-Coordinates-NDC" class="headerlink" title="标准化设备坐标(Normalized Device Coordinates, NDC)"></a>标准化设备坐标(Normalized Device Coordinates, NDC)</h4><p>一旦你的顶点坐标已经在顶点着色器中处理过，它们就应该是标准化设备坐标了，标准化设备坐标是一个 x、y 和 z 值在 -1.0 到 1.0 的一小段空间，任何落在范围外的坐标都会被丢弃/裁剪，不会显示在你的屏幕上。</p><p>下面你会看到我们定义的在标准化设备坐标中的三角形(忽略z轴)：</p><p><img src="/images/posts/opengl/render_pipeline/normalized-device-coordinates.png" alt></p><p>你的标准化设备坐标接着会变换为屏幕<strong>空间坐标(Screen-spaceCoordinates)</strong>，这是通过 <code>glViewport</code> 函数提供的数据，进行<strong>视口变换(ViewportTransform)</strong>完成的，所得的屏幕空间坐标又会被变换为片段输入到片段着色器中。</p><p>由于我们希望渲染一个三角形，我们一共要指定三个顶点，每个顶点都有一个 3D 位置，我们要将它们以标准化设备坐标的形式（OpenGL 的可见区域）输入，所以我们定义为一个 float 数组为<strong>顶点数据(Vertex Data)</strong>：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,<span class="comment">//左</span></span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,<span class="comment">//右</span></span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span> <span class="comment">//上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>由于 OpenGL 是在 3D 空间中工作的，而我们渲染的是一个 2D 三角形，我们将它顶点的 z 坐标设置为 0.0，这样子的话三角形每一点的 <strong>深度 (Depth)</strong>都是一样的，从而使它看上去像是 2D 的。深度可以理解为 z 坐标，它代表一个像素在空间中和你(屏幕)的距离，如果离你远就可能被别的像素遮挡，你就看不到它了，它会被丢弃，以节省资源。</p><p>创建之后，我们要考虑如何传输。顶点数据是要从 CPU 发往 GPU 上参与运算的，顶点数据通过 CPU 输入到 GPU 的<strong>顶点着色器</strong>之前，我们先要在 GPU 上创建内存（显存）空间，用于储存我们的顶点数据，还要配置 OpenGL 如何读懂这些数据，并且指定其如何发送给显卡，然后才轮到<strong>顶点着色器</strong>处理我们在内存中指定的顶点。</p><p>但是，<strong>从 CPU 把数据发送到 GPU 是一个相对较慢的过程</strong>，每个顶点发送一次耗费的时间将会非常大，所以我们要一次性发送尽可能多的数据，因此我们需要一个中介：<strong>顶点缓冲对象(Vertex Buffer Objects, VBO)</strong>，来管理这内存，它会在 GPU 内存（显存）中储存大量顶点，因此我们就能一批一批发送大量顶点数据到 GPU 内存（显存）了。而当数据储存到 GPU 的内存（显存）中后，顶点着色器几乎能立即访问顶点，这是个非常快的过程。</p><h3 id="顶点缓冲对象-VBO"><a href="#顶点缓冲对象-VBO" class="headerlink" title="顶点缓冲对象 VBO"></a>顶点缓冲对象 VBO</h3><p>VBO 可以将输入的顶点数据<strong>原封不动</strong>的存起来。</p><p>和 OpenGL 中的其它对象一样，这个缓冲必须要有一个独一无二的 ID，所以我们需要一个整形变量，再使用 <code>glGenBuffers</code> 函数，他会生成缓冲并返回对应的 ID 存到第二个参数上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;VBO); <span class="comment">// glGenBuffers(缓冲区绑定对象目标数量，缓冲区对象名称(ID))</span></span><br><span class="line"><span class="comment">// glGenBuffers 可以产生多个 VBO，但是我们现在只要一个。如果你一次生成 10 个，第一个参数要改成 10，并且你就需要声明一个整形数组而不是一个整形变量。</span></span><br></pre></td></tr></table></figure><p>OpenGL 有很多缓冲对象类型，<strong>顶点缓冲对象</strong>的缓冲类型是 <code>GL_ARRAY_BUFFER</code>，OpenGL 允许我们同时绑定多个缓冲，只要它们是不同的缓冲类型。我们可以使用 <code>glBindBuffer</code> 函数把新创建的缓冲<strong>绑定</strong>到 <code>GL_ARRAY_BUFFER</code> 目标上：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO); <span class="comment">// glBindBuffer(目标缓冲类型, 对象名称(ID))</span></span><br></pre></td></tr></table></figure><p>要注意，<code>glGenBuffers</code> 只是生成缓冲，程序并不知道这个缓冲是什么类型。所以调用 <code>glBindBuffer</code> 并制定缓冲类型，我们才算真正创建了一个 VBO。</p><p>接下来我们要<strong>把顶点数据存到 VBO 上</strong>，调用 <code>glBufferData</code> 函数：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glBufferData(</span><br><span class="line">    GL_ARRAY_BUFFER,  <span class="comment">//目标缓冲类型</span></span><br><span class="line">    <span class="keyword">sizeof</span>(vertices), <span class="comment">//传输数据的大小</span></span><br><span class="line">    vertices,         <span class="comment">//发送的实际数据</span></span><br><span class="line">    GL_STATIC_DRAW    <span class="comment">//管理给定的数据的方式</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>glBufferData</code> 是一个专门用来<strong>把用户定义的数据复制到当前绑定缓冲</strong>的函数。</p><ol><li>第一个参数是目标缓冲的类型：顶点缓冲对象当前绑定到 <code>GL_ARRAY_BUFFER</code> 目标上。</li><li>第二个参数指定传输数据的大小(以字节为单位)；用一个简单的 <code>sizeof</code> 计算出顶点数据大小就行。</li><li>第三个参数是我们希望发送的实际数据。</li><li>第四个参数指定了我们希望显卡如何管理给定的数据，它有三种形式：<ul><li><code>GL_STATIC_DRAW</code> ：数据不会或几乎不会改变。</li><li><code>GL_DYNAMIC_DRAW</code>：数据会被改变很多。</li><li><code>GL_STREAM_DRAW</code> ：数据每次绘制时都会改变。</li></ul></li></ol><p>三角形的位置数据不会改变，每次渲染调用时都保持原样，所以它的使用类型最好是 <code>GL_STATIC_DRAW</code>。如果一个缓冲中的数据将频繁被改变，那么使用的类型就应该是 <code>GL_DYNAMIC_DRAW</code> 或 <code>GL_STREAM_DRAW</code>，这样就能确保显卡把数据放在能够高速写入的内存部分。</p><p>目前我们完成的是：</p><ol><li>建立一批顶点数据存在 vertices 数组里。</li><li>在显存上创建了一个 VBO。</li><li>将顶点数据存在了 VBO 中，GPU 可以通过 VBO 读取顶点数据。</li></ol><p>之前也提到了，VBO 只是将输入的顶点数据<strong>原封不动的保存在显存中供 GPU 使用</strong>，接下来我们需要对这些数据加以解释，<strong>输入数据的哪到哪是一个部分，每个部分对应什么</strong>，让 GPU 读懂。</p><h3 id="链接顶点属性"><a href="#链接顶点属性" class="headerlink" title="链接顶点属性"></a>链接顶点属性</h3><p>由于我们需要画三角形，传入的数据是三个顶点，所以我们希望 VBO 内的数据会被解析为下面这样子：</p><p><img src="/images/posts/opengl/render_pipeline/vertex-property.png" alt></p><ul><li>位置数据被储存为 32 位（4 字节）浮点值。</li><li>每个位置包含 3 个这样的值。</li><li>在这 3 个值之间没有空隙（或其他值），这几个值在数组中紧密排列。</li><li>数据中第一个值在缓冲开始的位置 0 。</li></ul><p>有了这些信息我们就可以使用 <code>glVertexAttribPointer()</code> 函数告诉 OpenGL 该如何解析顶点数据了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">glVertexAttribPointer(</span><br><span class="line">    <span class="number">0</span>,                  <span class="comment">//指定要配置的Location</span></span><br><span class="line">    <span class="number">3</span>,                  <span class="comment">//指定顶点属性的大小</span></span><br><span class="line">    GL_FLOAT,           <span class="comment">//指定数据的类型</span></span><br><span class="line">    GL_FALSE,           <span class="comment">//是否希望数据被标准化</span></span><br><span class="line">    <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>),  <span class="comment">//连续的顶点属性组之间的间隔</span></span><br><span class="line">    (<span class="keyword">void</span>*)<span class="number">0</span>            <span class="comment">//偏移量</span></span><br><span class="line">);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p><code>glVertexAttribPointer</code> 函数的参数非常多，这里逐一介绍它们：</p><ol><li>第一个参数<strong>指定我们要配置的顶点属性</strong>，我们之后需要在顶点着色器中使用 <code>layout(location = 0)</code> 定义 position 顶点属性的位置值(Location)。把顶点属性的位置值同样设置为 0 。</li><li>第二个参数<strong>指定顶点属性的大小</strong>，顶点属性是一个 <code>vec3</code>，它由 3个 值组成，所以大小是 3 。</li><li>第三个参数<strong>指定数据的类型</strong>，这里是 <code>GL_FLOAT</code> (GLSL 中 <code>vec*</code> 都是由浮点数值组成的)。</li><li>第四个参数定义我们<strong>是否希望数据被标准化</strong>(Normalize)，如果我们置为 <code>GL_TRUE</code>，所有数据都会被映射到 0 到 1 之间（对于有符号型signed数据是-1），我们把它置为 <code>GL_FALSE</code>。</li><li>第五个参数叫做步长(Stride)，它告诉我们在<strong>连续的顶点属性组之间的间隔</strong>，由于下个组位置数据在 3 个 float 之后，我们把步长设置为 <code>3 * sizeof(float)</code>，要注意的是由于我们知道这个数组是紧密排列的（在两个顶点属性之间没有空隙）我们也可以<strong>设置为 0 来让 OpenGL 决定</strong>具体步长是多少（只有当数值是紧密排列时才可用），一旦我们有更多的顶点属性，我们就必须更小心地定义每个顶点属性之间的间隔。</li><li>最后一个参数的类型是 <code>void*</code>，所以需要我们进行这个奇怪的强制类型转换，它表示位置数据在缓冲中起始位置的<strong>偏移量(Offset)</strong>，由于位置数据在数组的开头，所以这里是 0，我们会在后面详细解释这个参数。</li></ol><p>如果程序中可以有多个 VBO，OpenGL怎么判断从哪个 VBO 获取呢？绑定是 OpenGL 中很重要的一个概念，还记得我们之前调用 <code>glVertexAttribPointer()</code> 时将 VBO 绑定到 <code>GL_ARRAY_BUFFER</code> 吗？<strong>在调用 <code>glVertexAttribPointer()</code> 之前绑定的是哪个 VBO，链接的就是它</strong>。</p><blockquote><p>换句话说，调用 <code>glVertexAttribPointer()</code> 时使用的 VBO 是当前被绑定到 <code>GL_ARRAY_BUFFER</code> 上的缓冲区。</p></blockquote><p>我们已经告诉了 OpenGL 该如何解释顶点数据，目前的进度是：</p><ol><li>建立了一批顶点数据存在 vertices 数组里。</li><li>在显存上创建了一个 VBO。</li><li>将顶点数据存在了 VBO 中，GPU 可以通过 VBO 读取顶点数据。</li><li>告诉了 OpenGL 如何把顶点数据链接到顶点着色器的顶点属性上。</li></ol><p>在 OpenGL 中绘制一个物体的准备工作流程大致如下代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 0. 复制顶点数组到VBO缓冲中供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 绘制代码(渲染循环中)</span></span><br><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 2. 渲染一个物体时要使用着色器程序</span></span><br><span class="line">    glUseProgram(shaderProgram);</span><br><span class="line">    <span class="comment">// 3. 绘制物体</span></span><br><span class="line">    someOpenGLFunctionThatDrawsOurTriangle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每当我们绘制一个物体的时候都必须重复这一过程，看起来可能不多，但是如果有超过 5 个顶点属性，上百个不同物体时，绑定正确的缓冲对象，为每个物体配置所有顶点属性就会非常麻烦。有没有一些方法可以使我们<strong>把所有这些状态配置储存在另一个对象中</strong>，并且可以通过绑定这个对象来恢复状态呢？顶点数组对象 VAO 可以完成这项功能。</p><h3 id="顶点数组对象-VAO"><a href="#顶点数组对象-VAO" class="headerlink" title="顶点数组对象 VAO"></a>顶点数组对象 VAO</h3><p><strong>顶点数组对象(Vertex Array Object, VAO)</strong> 可以记录我们对 VBO 内顶点数据的配置，当配置顶点属性指针时，你只需要将之前那些调用执行一次，之后再绘制物体的时候只需要<strong>绑定相应的 VAO</strong> 就行了，这使在不同顶点数据和属性配置之间切换变得非常简单，只需要绑定不同的 VAO 就行了，刚刚设置的所有状态都将存储在 VAO 中。</p><p>OpenGL 的核心模式<strong>要求</strong>我们使用 VAO，所以它知道该如何处理我们的顶点输入，如果我们绑定 VAO 失败，OpenGL会拒绝绘制任何东西。</p><p>一个顶点数组对象会储存以下这些内容：</p><ul><li><code>glEnableVertexAttribArray()</code> 和 <code>glDisableVertexAttribArray()</code> 的调用。</li><li>通过 <code>glVertexAttribPointer()</code> 设置的顶点属性配置。</li><li>通过 <code>glVertexAttribPointer()</code> 调用与顶点属性关联的顶点缓冲对象。</li></ul><p>VBO 和 VAO 的关系如下图：</p><p><img src="/images/posts/opengl/render_pipeline/vao-vbo.png" alt></p><p>所以通常我们是<strong>一个绘制的物体对应一个 VAO</strong>。创建一个VAO和创建一个VBO很类似：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br></pre></td></tr></table></figure><p>要想使用 VAO，只需调用 <code>glBindVertexArray()</code> 绑定VAO。</p><p>从绑定之后起，我们应该绑定和配置对应的 VBO 和属性指针，之后解绑 VAO 供之后使用，当我们打算绘制一个物体的时候，我们只要在绘制物体前简单地把 VAO 绑定到希望使用的设定上就行了。</p><p>这段代码应该看起来像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化代码,只运行一次 (除非你的物体频繁改变)</span></span><br><span class="line"><span class="comment">// 1. 绑定 VAO</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. 把顶点数组复制到缓冲中供 OpenGL 使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"><span class="comment">// 绘制代码(渲染循环中)</span></span><br><span class="line"><span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 4. 绘制物体</span></span><br><span class="line">    glUseProgram(shaderProgram);</span><br><span class="line">    glBindVertexArray(VAO); <span class="comment">//绑定 VAO</span></span><br><span class="line">    someOpenGLFunctionThatDrawsOurTriangle();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们打算绘制多个物体，就先要配置每种物体的 VBO 和 VAO ，储存它们供后面使用，绘制物体的时候就拿出相应的 VAO，绑定它，绘制完后再解绑 VAO。</p><p>比如我们需要两种不同的三角形时，首先需要两个三角形的顶点数据：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> firstTriangle[] = &#123;</span><br><span class="line">    <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">    <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">float</span> secondTriangle[] = &#123;</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left</span></span><br><span class="line">    <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后创建两个 VAO ，两个 VBO（是不是可以只用一个VBO呢？）。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBOs[<span class="number">2</span>], VAOs[<span class="number">2</span>];</span><br><span class="line">glGenVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">glGenBuffers(<span class="number">2</span>, VBOs);</span><br></pre></td></tr></table></figure><p>分别设置：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">0</span>]);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(firstTriangle), firstTriangle, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">1</span>]);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(secondTriangle), secondTriangle, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>渲染：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>释放资源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glfwTerminate();</span><br><span class="line">glDeleteVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">glDeleteBuffers(<span class="number">2</span>, VBOs);</span><br></pre></td></tr></table></figure><h2 id="着色器"><a href="#着色器" class="headerlink" title="着色器"></a>着色器</h2><p>如果我们打算做渲染的话，现代 OpenGL 需要我们至少设置一个顶点和一个片段着色器，接下来我们先简单介绍一下着色器，然后配置两个非常简单的着色器：<strong>顶点着色器(Vertex Shader)</strong>和<strong>片段着色器(Fragment Shader)</strong>，用来来绘制我们第一个三角形。</p><blockquote><p>在图形编程中我们经常会使用向量这个数学概念，因为它简明地表达了任意空间中的位置和方向，并且它有非常有用的数学属性。在 GLSL 中一个向量有最多 4 个分量，每个分量值都代表空间中的一个坐标，它们可以通过 <code>vec.x</code>、<code>vec.y</code>、<code>vec.z</code> 和 <code>vec.w</code> 来获取，注意 <code>vec.w</code> 分量不是用作表达空间中的位置的（我们处理的是3D不是4D），而是用在所谓的透视除法(Perspective Division)上。</p></blockquote><h3 id="顶点着色器"><a href="#顶点着色器" class="headerlink" title="顶点着色器"></a>顶点着色器</h3><p>还记得上面说的吗？顶点着色器是我们图形渲染管线的第一个部分，<strong>顶点着色器(Vertex Shader)</strong>，它把一个单独的顶点作为输入，顶点着色器主要的目的是把 3D 坐标转为另一种 3D 坐标，同时顶点着色器允许我们对顶点属性进行一些基本处理。</p><p>我们需要做的第一件事是学习使用<strong>着色器语言 GLSL(OpenGL Shading Language)</strong>编写顶点着色器，然后编译这个着色器，这样我们就可以在程序中使用它了。和学初级语言时写的 HelloWorld 一样，下面我们先看一段非常简单的顶点着色器的源代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不难看出 GLSL 看起来很像 C 语言，接下来我们一句句看。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br></pre></td></tr></table></figure><p>首先，每个着色器都起始于一个版本声明，OpenGL 3.3 以及和更高版本中，GLSL 版本号和 OpenGL 的版本是匹配的（比如说 GLSL420 版本对应于 OpenGL4.2），我们这里声明使用 3.30 版本，并且使用核心模式。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos; <span class="comment">//声明输入顶点属性</span></span><br></pre></td></tr></table></figure><p>下一步，使用 <code>in</code> 关键字，在顶点着色器中声明所有的<strong>输入顶点属性(Input Vertex Attribute)</strong> 。之前我们用 <code>glVertexAttribPointer()</code> 的第一个参数指定了输入的 location 为 0 ，所以需要通过 <code>layout (location = 0)</code> 设定输入变量的位置值(Location)为 0。现在我们只关心位置(Position)数据，所以我们只需要一个顶点属性。由于每个顶点都有一个 3D 坐标，我们就创建一个 <code>vec3</code>输入变量 aPos。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line"><span class="comment">// gl_Position的值即为输出</span></span><br></pre></td></tr></table></figure><p>为了设置顶点着色器的输出，我们必须把位置数据赋值给预定义的 <code>gl_Position</code> 变量（<code>vec4</code>类型）。在 <code>main</code> 函数里，<code>gl_Position</code> 最后的值就是该顶点着色器的<strong>输出</strong>。</p><p>由于我们的输入是一个 3 分量的向量，我们必须把它转换为 <code>gl_Position</code> 所对应的 4 分量的向量。我们可以把 <code>vec3</code> 的数据作为 <code>vec4</code> 构造器的参数，同时把 <code>w</code> 分量设置为 1.0f（后面解释为什么）。</p><p>很简单，就这样写完了，再看一次我们这个顶点着色器的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 顶点着色器</span></span><br><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">layout (location = <span class="number">0</span>) in vec3 aPos;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    gl_Position = vec4(aPos.x, aPos.y, aPos.z, <span class="number">1.0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当前这个顶点着色器可能是我们能想到的最简单的顶点着色器了，因为我们对输入数据什么都没有处理就把它传到着色器的输出了（在真实的程序里输入数据通常都不是标准化设备坐标，所以我们首先必须先把它们转换至 OpenGL 的可视区域内，但是现在我们可以先不考虑）。</p><h4 id="编译顶点着色器"><a href="#编译顶点着色器" class="headerlink" title="编译顶点着色器"></a>编译顶点着色器</h4><p>我们已经写了一个顶点着色器源码，但是为了能够让 OpenGL 使用它，我们必须在<strong>运行时动态编译它的源码</strong>，我们写的顶点着色器源码将储存在一个 C 的字符串中：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br></pre></td></tr></table></figure><p>(很恶心，但我们之后会通过文件读写解决这个问题的，不用着急)</p><p>我们首先要做的是创建一个着色器对象，注意还是用 ID 来引用的，所以我们储存这个顶点着色器的 ID 为 <code>unsigned int</code>，然后用 <code>glCreateShader</code> 创建这个着色器，我们把需要创建的着色器类型以参数形式提供给<br><code>glCreateShader</code>，由于我们正在创建一个顶点着色器，传递的参数是 <code>GL_VERTEX_SHADER</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br></pre></td></tr></table></figure><p>下一步我们把这个着色器源码附加到着色器对象上，然后编译它：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glShaderSource(</span><br><span class="line">    vertexShader,        <span class="comment">//要编译的着色器对象</span></span><br><span class="line">    <span class="number">1</span>,                   <span class="comment">//传递的源码字符串数量</span></span><br><span class="line">    &amp;vertexShaderSource, <span class="comment">//顶点着色器源码</span></span><br><span class="line">    <span class="literal">NULL</span></span><br><span class="line">);</span><br><span class="line">glCompileShader(vertexShader);</span><br></pre></td></tr></table></figure><p><code>glShaderSource()</code> 函数的参数：</p><ol><li>第一个参数是要编译的着色器对象。</li><li>第二参数指定了传递的源码字符串数量，这里只有一个。</li><li>第三个参数是顶点着色器源码。</li><li>第四个参数我们先设置为 <code>NULL</code>。</li></ol><p>同时，我们希望检测在调用 <code>glCompileShader</code> 后编译是否成功了，如果没成功的话，也希望知道错误是什么，这样才能方便修复它们，检测编译时错误输出可以通过以下代码来实现：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> success;        <span class="comment">//是否成功编译</span></span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];  <span class="comment">//储存错误消息</span></span><br><span class="line">glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);   <span class="comment">//检查是否编译成功</span></span><br><span class="line"><span class="keyword">if</span>(!success)</span><br><span class="line">&#123;</span><br><span class="line">    glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先我们定义一个整型变量 <code>success</code> 来表示是否成功编译，还定义了一个储存错误消息（出错了才会有）的容器 <code>infoLog[]</code> ，这是个 char 类型的数组，然后我们用 <code>glGetShaderiv</code> 函数检查是否编译成功，如果编译失败，我们会用 <code>glGetShaderInfoLog()</code> 获取错误消息，然后打印它。如果编译的时候没有检测到任何错误，顶点着色器就被编译成功了。</p><h3 id="片段着色器"><a href="#片段着色器" class="headerlink" title="片段着色器"></a>片段着色器</h3><p>我们刚才通过顶点着色器的 <code>gl_Position</code> 变量设置了三角形三个点的位置，现在我们要在片段着色器里设置他们的颜色。</p><p><strong>片段着色器(Fragment Shader)</strong>的主要目的是计算一个像素的最终颜色，这也是所有 OpenGL 高级效果产生的地方，通常，片段着色器包含 3D 场景的数据（比如光照、阴影、光的颜色等等），这些数据可被用来计算最终像素的颜色。</p><p>在计算机图形中颜色被表示为有 4 个元素的数组：<strong>红色、绿色、蓝色和alpha(透明度)分量</strong>，通常缩写为 RGBA。当在 OpenGL 中定义一个颜色的时候，我们把颜色每个分量的强度设置在 0.0 到 1.0 之间。比如说我们设置红为 1.0f，绿为 1.0f，我们会得到两个颜色的混合色，即黄色。这三种颜色分量的不同调配可以生成超过1600万种不同的颜色。</p><p>现在看到我们的片段着色器代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#version 330 core</span></span><br><span class="line">out vec4 FragColor;<span class="comment">//只需要一个输出变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FragColor = vec4(<span class="number">1.0f</span>, <span class="number">0.5f</span>, <span class="number">0.2f</span>, <span class="number">1.0f</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>片段着色器只需要一个输出变量，这个变量是一个 4 分量向量，它表示的是最终的输出颜色，我们可以用 out 关键字声明输出变量，这里我们命名为 <code>FragColor</code>。我们将一个 alpha 值为 1.0（代表完全不透明）的橘黄色的 vec4 赋值给颜色输出 <code>FragColor</code>。</p><h4 id="编译片段着色器"><a href="#编译片段着色器" class="headerlink" title="编译片段着色器"></a>编译片段着色器</h4><p>编译片段着色器的过程与顶点着色器类似，不过我们使用 <code>GL_FRAGMENT_SHADER</code> 常量作为着色器类型：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">glCompileShader(fragmentShader);</span><br></pre></td></tr></table></figure><p>我们同样用刚才的方法检测编译是否出错：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> success;<span class="comment">//是否成功编译</span></span><br><span class="line"><span class="keyword">char</span> infoLog[<span class="number">512</span>];<span class="comment">//储存错误消息</span></span><br><span class="line">glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span> (!success) &#123;</span><br><span class="line">    glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>没有检测到任何错误，片段着色器也被编译成功了。好了，现在两个着色器现在都编译了，总的代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//build and compile 着色器程序（main内）</span></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">        <span class="comment">//检查顶点着色器是否编译错误</span></span><br><span class="line">    <span class="keyword">int</span>  success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">        <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后我们要把两个着色器对象链接到一个用来渲染的着色器程序(Shader Program)中。</p><h3 id="着色器程序"><a href="#着色器程序" class="headerlink" title="着色器程序"></a>着色器程序</h3><p>着色器程序对象(Shader Program Object)是多个着色器合并之后并最终链接完成的版本，如果要使用刚才编译的着色器我们必须把它们链接(Link)为一个着色器程序对象，然后在渲染对象的时候激活这个着色器程序。已激活着色器程序的着色器将在我们发送渲染调用的时候被使用。</p><p>当链接着色器至一个程序的时候，它会把每个着色器的输出链接到下个着色器的输入，如果输出和输入不匹配，就会得到一个连接错误。</p><p>创建一个程序对象很简单，像刚才一样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">shaderProgram = glCreateProgram();</span><br></pre></td></tr></table></figure><p><code>glCreateProgram()</code> 函数创建一个程序，并返回新创建程序对象的 ID 引用。</p><p>现在我们需要把之前编译的着色器附加到程序对象上，然后用 <code>glLinkProgram()</code> 链接它们：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">glLinkProgram(shaderProgram);</span><br></pre></td></tr></table></figure><p>代码应该很清楚，我们把着色器附加到了程序上，然后用 <code>glLinkProgram()</code> 链接。</p><p>就像着色器的编译一样，我们也可以检测链接着色器程序是否失败，并获取相应的日志</p><p>与上面不同，我们尝试不调用 <code>glGetShaderiv()</code> 和 <code>glGetShaderInfoLog()</code>，而是使用 <code>glGetProgramiv()</code> 和 <code>glGetProgramInfoLog()</code> ：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line"><span class="keyword">if</span>(!success) &#123;</span><br><span class="line">    glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgram complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果着色器程序没有报错，我们通过 <code>glLinkProgram()</code> 得到的就是一个程序对象，我们可以调用 <code>glUseProgram()</code> 函数，用刚创建的程序对象作为它的参数，以激活这个程序对象：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);    <span class="comment">//写进渲染循环</span></span><br></pre></td></tr></table></figure><p>在 <code>glUseProgram()</code> 函数调用之后，每个着色器调用和渲染调用都会使用这个程序对象（也就是之前写的着色器）了。</p><p>对了，<strong>在把着色器对象链接到程序对象以后，记得删除着色器对象</strong>，我们不再需要它们了：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDeleteShader(vertexShader);</span><br><span class="line">glDeleteShader(fragmentShader);</span><br></pre></td></tr></table></figure><h2 id="画出三角形"><a href="#画出三角形" class="headerlink" title="画出三角形"></a>画出三角形</h2><p>庆贺吧，终于来到了这一刻。</p><p>要想绘制我们想要的物体，OpenGL 给我们提供了 <code>glDrawArrays()</code> 函数，它使用当前激活的着色器，之前定义的顶点属性配置，和 VBO 的顶点数据（通过 VAO 间接绑定）来绘制图元：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawArrays(</span><br><span class="line">    GL_TRIANGLES,   <span class="comment">//图元的类型</span></span><br><span class="line">    <span class="number">0</span>,              <span class="comment">//顶点数组的起始索引</span></span><br><span class="line">    <span class="number">3</span>               <span class="comment">//绘制多少个顶点</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>glDrawArrays()</code> 函数：</p><ol><li>第一个参数是我们打算绘制的 OpenGL 图元的类型，由于我们在一开始时说过，我们希望绘制的是一个三角形，这里传递 GL_TRIANGLES 给它。</li><li>第二个参数指定了顶点数组的起始索引，我们这里填 0 。</li><li>最后一个参数指定我们打算绘制多少个顶点，这里是 3（我们只从我们的数据中渲染一个三角形，它只有3个顶点长）。</li></ol><p>现在尝试编译代码，如果编译通过了，你应该看到下面的结果：</p><p><img src="/images/posts/opengl/render_pipeline/result.png" alt></p><p>这时候我们的代码是这样的：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化GLFW窗口</span></span><br><span class="line">    glfwInit();<span class="comment">//glfw初始化</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//（宽，高，窗口名）返回一个GLFWwindow类的实例：window</span></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉GLFW我们希望每当窗口调整大小的时候调用改变窗口大小的函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad管理opengl函数指针，初始化glad</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build and compile 着色器程序</span></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">//检查顶点着色器是否编译错误</span></span><br><span class="line">    <span class="keyword">int</span>  success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">    shaderProgram = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgram complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接后删除</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数据</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,</span><br><span class="line">     <span class="number">0.0f</span>,  <span class="number">0.5f</span>, <span class="number">0.0f</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化代码</span></span><br><span class="line">    <span class="comment">// 1. 绑定VAO</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 2. 把顶点数组复制到缓冲中供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 设置顶点属性指针</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查触发什么事件，更新窗口状态</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放之前的分配的所有资源</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回这个按键是否正在被按下</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<span class="comment">//是否按下了返回键</span></span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引缓冲对象"><a href="#索引缓冲对象" class="headerlink" title="索引缓冲对象"></a>索引缓冲对象</h2><p>在渲染顶点这一话题上我们还有最后一个需要讨论的东西——<strong>索引缓冲对象</strong>(Element Buffer Object，<strong>EBO</strong>，也叫Index Buffer Object，IBO)</p><p>假设我们不再绘制一个三角形而是绘制一个矩形，我们可以<strong>绘制两个三角形来组成一个矩形</strong>（OpenGL 主要处理三角形）这会生成下面的顶点的集合：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 右上角</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 左上角</span></span><br><span class="line">    <span class="comment">// 第二个三角形</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 右下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 左下角</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 左上角</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>可以看到，有几个顶点叠加了：我们指定了右下角和左上角两次，一个矩形只有4个而不是6个顶点，这样就产生50%的额外开销。更好的解决方案是只储存不同的顶点，并<strong>设定绘制这些顶点的顺序</strong>，这样子我们只要储存 4 个顶点就能绘制矩形了，之后只要指定绘制的顺序就行了。</p><p><strong>索引缓冲对象 EBO</strong> 就是干这个的，和顶点缓冲对象一样，EBO 也是一个缓冲，它<strong>专门储存索引</strong>，OpenGL 调用这些顶点的索引来决定该绘制哪个顶点。</p><p>首先，我们先要定义（不重复的）顶点，和绘制出矩形所需的索引：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 0号点</span></span><br><span class="line">    <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 1号点</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 2号点</span></span><br><span class="line">    <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 3号点</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始!</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>你可以看到，当时用索引的时候，我们只定义了 4 个顶点，下一步我们需要创建索引缓冲对象，与 VBO 类似，我们先绑定 EBO 然后用 <code>glBufferData()</code> 把索引复制到缓冲里。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br></pre></td></tr></table></figure><p>同样，和 VBO 类似，我们会把这些函数调用放在绑定和解绑函数调用之间，只不过这次我们把缓冲的类型定义为 <code>GL_ELEMENT_ARRAY_BUFFER</code>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br></pre></td></tr></table></figure><p>要注意的是，我们传递了 <code>GL_ELEMENT_ARRAY_BUFFER</code> 当作缓冲目标。</p><p>最后一件要做的事是用 <code>glDrawElements()</code> 来替换 <code>glDrawArrays()</code> 函数，来指明我们从索引缓冲渲染。使用 <code>glDrawElements()</code> 时，我们会使用当前绑定的索引缓冲对象中的索引进行绘制：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line"></span><br><span class="line"><span class="comment">//glDrawArrays(GL_TRIANGLES, 0, 6);</span></span><br><span class="line">glDrawElements(</span><br><span class="line">    GL_TRIANGLES,      <span class="comment">//绘制的模式</span></span><br><span class="line">    <span class="number">6</span>,                 <span class="comment">//绘制顶点的个数</span></span><br><span class="line">    GL_UNSIGNED_INT,   <span class="comment">//索引的类型</span></span><br><span class="line">    <span class="number">0</span>                  <span class="comment">//偏移量</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure><p><code>glDrawElements</code> 的参数：</p><ol><li>第一个参数指定了我们绘制的模式，这个和 <code>glDrawArrays()</code> 的一样。</li><li>第二个参数是我们打算绘制顶点的个数，这里填 6，也就是说我们一共需要绘制 6 个顶点。</li><li>第三个参数是索引的类型，这里是 <code>GL_UNSIGNED_INT</code>。</li><li>最后一个参数里我们可以指定 EBO 中的偏移量（或者传递一个索引数组，但是这是当你不在使用索引缓冲对象的时候），但是我们会在这里填写 0 。</li></ol><p><code>glDrawElements()</code> 函数从当前绑定到 <code>GL_ELEMENT_ARRAY_BUFFER</code> 目标的 EBO 中获取索引，这意味着我们必须在每次要用索引渲染一个物体时绑定相应的 EBO，还是有点麻烦。不过顶点数组对象同样可以保存索引缓冲对象的绑定状态，VAO 绑定时正在绑定的索引缓冲对象会被保存为 VAO 的元素缓冲对象，<strong>绑定 VAO 的同时也会自动绑定 EBO</strong>。</p><p><img src="/images/posts/opengl/render_pipeline/vao-ebo.png" alt></p><p>当目标是 <code>GL_ELEMENT_ARRAY_BUFFER</code> 的时候，VAO 会储存 <code>glBindBuffer()</code> 的函数调用，这也意味着它也会储存解绑调用，所以确保你没有在解绑 VAO 之前解绑索引数组缓冲，否则它就没有这个 EBO 配置了最后的初始化和绘制代码现在看起来像这样：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 初始化代码</span></span><br><span class="line"><span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line"><span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line"><span class="comment">// 4. 设定顶点属性指针</span></span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// .绘制代码（渲染循环中）</span></span><br><span class="line">glUseProgram(shaderProgram);</span><br><span class="line">glBindVertexArray(VAO);</span><br><span class="line">glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>)；</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>运行结果如下：</p><p><img src="/images/posts/opengl/render_pipeline/result2.png" alt></p><h2 id="扩展知识"><a href="#扩展知识" class="headerlink" title="扩展知识"></a>扩展知识</h2><h3 id="线框模式-Wireframe-Mode"><a href="#线框模式-Wireframe-Mode" class="headerlink" title="线框模式(Wireframe Mode)"></a>线框模式(Wireframe Mode)</h3><p>要想用线框模式绘制你的三角形，你可以通过 <code>glPolygonMode(GL_FRONT_AND_BACK, GL_LINE)</code> 函数配置 OpenGL 如何绘制图元。</p><ol><li>第一个参数表示我们打算将其应用到所有的三角形的正面和背面。</li><li>第二个参数告诉我们用线来绘制。</li></ol><p><strong>设定之后的绘制调用会一直以线框模式绘制三角形</strong>，直到我们用 <code>glPolygonMode(GL_FRONT_AND_BACK, GL_FILL)</code> 将其设置回默认模式。</p><p><img src="/images/posts/opengl/render_pipeline/result3.png" alt></p><p>可以看到这个矩形的确是由两个三角形组成的，完整代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化GLFW窗口</span></span><br><span class="line">    glfwInit();<span class="comment">//glfw初始化</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//（宽，高，窗口名）返回一个GLFWwindow类的实例：window</span></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉GLFW我们希望每当窗口调整大小的时候调用改变窗口大小的函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad管理opengl函数指针，初始化glad</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build and compile 着色器程序</span></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">//检查顶点着色器是否编译错误</span></span><br><span class="line">    <span class="keyword">int</span>  success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">    shaderProgram = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgram complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接后删除</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数据</span></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,   <span class="comment">// 0号点</span></span><br><span class="line">        <span class="number">0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// 1号点</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>, <span class="comment">// 2号点</span></span><br><span class="line">        <span class="number">-0.5f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// 3号点</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始!</span></span><br><span class="line">        <span class="number">0</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">        <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化代码</span></span><br><span class="line">    <span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span><br><span class="line">    glBufferData(GL_ELEMENT_ARRAY_BUFFER, <span class="keyword">sizeof</span>(indices), indices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 4. 设定顶点属性指针</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//线框模式wireframe</span></span><br><span class="line">    glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        glDrawElements(GL_TRIANGLES, <span class="number">6</span>, GL_UNSIGNED_INT, <span class="number">0</span>);</span><br><span class="line">        glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查触发什么事件，更新窗口状态</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放之前的分配的所有资源</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回这个按键是否正在被按下</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<span class="comment">//是否按下了返回键</span></span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="两个彼此相连的三角形"><a href="#两个彼此相连的三角形" class="headerlink" title="两个彼此相连的三角形"></a>两个彼此相连的三角形</h3><p>我们可以尝试添加更多顶点到数据中，使用 <code>glDrawArrays()</code>，绘制两个彼此相连的三角形。我们只需要更改顶点数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="comment">//第一个三角形</span></span><br><span class="line">    <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">    <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">    <span class="comment">//第二个三角形</span></span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left</span></span><br><span class="line">    <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>然后更改 EBO 设置（直接注了）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span></span><br><span class="line"><span class="comment">// glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span></span><br></pre></td></tr></table></figure><p>更改渲染指令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line"><span class="comment">// glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span></span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="/images/posts/opengl/render_pipeline/result4.png" alt></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化GLFW窗口</span></span><br><span class="line">    glfwInit();<span class="comment">//glfw初始化</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//（宽，高，窗口名）返回一个GLFWwindow类的实例：window</span></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉GLFW我们希望每当窗口调整大小的时候调用改变窗口大小的函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad管理opengl函数指针，初始化glad</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build and compile 着色器程序</span></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">//检查顶点着色器是否编译错误</span></span><br><span class="line">    <span class="keyword">int</span>  success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">    shaderProgram = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgram complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接后删除</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数据</span></span><br><span class="line">    <span class="comment">//float vertices[] = &#123;</span></span><br><span class="line">    <span class="comment">//    0.5f, 0.5f, 0.0f,   // 0号点</span></span><br><span class="line">    <span class="comment">//    0.5f, -0.5f, 0.0f,  // 1号点</span></span><br><span class="line">    <span class="comment">//    -0.5f, -0.5f, 0.0f, // 2号点</span></span><br><span class="line">    <span class="comment">//    -0.5f, 0.5f, 0.0f   // 3号点</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    <span class="comment">//unsigned int indices[] = &#123; // 注意索引从0开始!</span></span><br><span class="line">    <span class="comment">//    0, 1, 3, // 第一个三角形</span></span><br><span class="line">    <span class="comment">//    1, 2, 3  // 第二个三角形</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">        <span class="comment">//第一个三角形</span></span><br><span class="line">        <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">        <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">        <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">        <span class="comment">//第二个三角形</span></span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left</span></span><br><span class="line">        <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">        <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBO;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VAO;</span><br><span class="line">    glGenVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> EBO;</span><br><span class="line">    glGenBuffers(<span class="number">1</span>, &amp;EBO);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 初始化代码</span></span><br><span class="line">    <span class="comment">// 1. 绑定顶点数组对象</span></span><br><span class="line">    glBindVertexArray(VAO);</span><br><span class="line">    <span class="comment">// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBO);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(vertices), vertices, GL_STATIC_DRAW);</span><br><span class="line">    <span class="comment">// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span></span><br><span class="line">    <span class="comment">//glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span></span><br><span class="line">    <span class="comment">// 4. 设定顶点属性指针</span></span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">////线框模式wireframe</span></span><br><span class="line">    <span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        glBindVertexArray(VAO);</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>);</span><br><span class="line">        <span class="comment">// glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span></span><br><span class="line">        glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查触发什么事件，更新窗口状态</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放之前的分配的所有资源</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    glDeleteVertexArrays(<span class="number">1</span>, &amp;VAO);</span><br><span class="line">    glDeleteBuffers(<span class="number">1</span>, &amp;VBO);</span><br><span class="line">    <span class="comment">//glDeleteBuffers(1, &amp;EBO);</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回这个按键是否正在被按下</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<span class="comment">//是否按下了返回键</span></span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当然你也可以用上 EBO，更简单，我们需要这样改下顶点数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> vertices[] = &#123;</span><br><span class="line">    <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">    <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">    <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> indices[] = &#123; <span class="comment">// 注意索引从0开始!</span></span><br><span class="line">    <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="comment">// 第一个三角形</span></span><br><span class="line">    <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>  <span class="comment">// 第二个三角形</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>EBO设置和上文相同，结果是一样的。</p><h3 id="使用不同的-VAO-和-VBO"><a href="#使用不同的-VAO-和-VBO" class="headerlink" title="使用不同的 VAO 和 VBO"></a>使用不同的 VAO 和 VBO</h3><p>效果和之前是相同的，但是我们分别创建了两个不同的 VAO 和两个不同的 VBO，所以顶点数据也要分成两个数组：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">float</span> firstTriangle[] = &#123;</span><br><span class="line">    <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">    <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">float</span> secondTriangle[] = &#123;</span><br><span class="line">    <span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left</span></span><br><span class="line">    <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>VAO，VBO 代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//unsigned int VBO;</span></span><br><span class="line"><span class="comment">//glGenBuffers(1, &amp;VBO);</span></span><br><span class="line"><span class="comment">//unsigned int VAO;</span></span><br><span class="line"><span class="comment">//glGenVertexArrays(1, &amp;VAO);</span></span><br><span class="line"><span class="comment">//unsigned int EBO;</span></span><br><span class="line"><span class="comment">//glGenBuffers(1, &amp;EBO);</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> VBOs[<span class="number">2</span>], VAOs[<span class="number">2</span>];</span><br><span class="line">glGenVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">glGenBuffers(<span class="number">2</span>, VBOs);</span><br><span class="line"></span><br><span class="line"><span class="comment">//// 初始化代码</span></span><br><span class="line"><span class="comment">//// 1. 绑定顶点数组对象</span></span><br><span class="line"><span class="comment">//glBindVertexArray(VAO);</span></span><br><span class="line"><span class="comment">//// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line"><span class="comment">//glBindBuffer(GL_ARRAY_BUFFER, VBO);</span></span><br><span class="line"><span class="comment">//glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span><br><span class="line"><span class="comment">//// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line"><span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span></span><br><span class="line"><span class="comment">//glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span></span><br><span class="line"><span class="comment">//// 4. 设定顶点属性指针</span></span><br><span class="line"><span class="comment">//glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span></span><br><span class="line"><span class="comment">//glEnableVertexAttribArray(0);</span></span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">0</span>]);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(firstTriangle), firstTriangle, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">1</span>]);</span><br><span class="line">glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(secondTriangle), secondTriangle, GL_STATIC_DRAW);</span><br><span class="line">glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">glEnableVertexAttribArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>渲染指令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">glUseProgram(shaderProgram);</span><br><span class="line"><span class="comment">//glBindVertexArray(VAO);</span></span><br><span class="line"><span class="comment">//glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span></span><br><span class="line">glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">glBindVertexArray(<span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>释放资源：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 释放之前的分配的所有资源</span></span><br><span class="line">glfwTerminate();</span><br><span class="line"><span class="comment">//glDeleteVertexArrays(1, &amp;VAO);</span></span><br><span class="line"><span class="comment">//glDeleteBuffers(1, &amp;VBO);</span></span><br><span class="line"><span class="comment">//glDeleteBuffers(1, &amp;EBO);</span></span><br><span class="line">glDeleteVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">glDeleteBuffers(<span class="number">2</span>, VBOs);</span><br></pre></td></tr></table></figure><p>全部源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化GLFW窗口</span></span><br><span class="line">    glfwInit();<span class="comment">//glfw初始化</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//（宽，高，窗口名）返回一个GLFWwindow类的实例：window</span></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉GLFW我们希望每当窗口调整大小的时候调用改变窗口大小的函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad管理opengl函数指针，初始化glad</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build and compile 着色器程序</span></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">//检查顶点着色器是否编译错误</span></span><br><span class="line">    <span class="keyword">int</span>  success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShader;</span><br><span class="line">    fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShader, <span class="number">1</span>, &amp;fragmentShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShader);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgram;</span><br><span class="line">    shaderProgram = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgram, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgram, fragmentShader);</span><br><span class="line">    glLinkProgram(shaderProgram);</span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgram, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgram complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//连接后删除</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    glDeleteShader(fragmentShader);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数据</span></span><br><span class="line">    <span class="comment">//float vertices[] = &#123;</span></span><br><span class="line">    <span class="comment">//    0.5f, 0.5f, 0.0f,   // 0号点</span></span><br><span class="line">    <span class="comment">//    0.5f, -0.5f, 0.0f,  // 1号点</span></span><br><span class="line">    <span class="comment">//    -0.5f, -0.5f, 0.0f, // 2号点</span></span><br><span class="line">    <span class="comment">//    -0.5f, 0.5f, 0.0f   // 3号点</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    <span class="comment">//unsigned int indices[] = &#123; // 注意索引从0开始!</span></span><br><span class="line">    <span class="comment">//    0, 1, 3, // 第一个三角形</span></span><br><span class="line">    <span class="comment">//    1, 2, 3  // 第二个三角形</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//float vertices[] = &#123;</span></span><br><span class="line">    <span class="comment">//    -0.9f, -0.5f, 0.0f,  // left </span></span><br><span class="line">    <span class="comment">//    -0.0f, -0.5f, 0.0f,  // right</span></span><br><span class="line">    <span class="comment">//    -0.45f, 0.5f, 0.0f,  // top </span></span><br><span class="line">    <span class="comment">//    0.9f, -0.5f, 0.0f,  // right</span></span><br><span class="line">    <span class="comment">//    0.45f, 0.5f, 0.0f   // top </span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    <span class="comment">//unsigned int indices[] = &#123; // 注意索引从0开始!</span></span><br><span class="line">    <span class="comment">//    0, 1, 2, // 第一个三角形</span></span><br><span class="line">    <span class="comment">//    1, 3, 4  // 第二个三角形</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> firstTriangle[] = &#123;</span><br><span class="line">    <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">    <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">float</span> secondTriangle[] = &#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left</span></span><br><span class="line">        <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">        <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unsigned int VBO;</span></span><br><span class="line">    <span class="comment">//glGenBuffers(1, &amp;VBO);</span></span><br><span class="line">    <span class="comment">//unsigned int VAO;</span></span><br><span class="line">    <span class="comment">//glGenVertexArrays(1, &amp;VAO);</span></span><br><span class="line">    <span class="comment">//unsigned int EBO;</span></span><br><span class="line">    <span class="comment">//glGenBuffers(1, &amp;EBO);</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBOs[<span class="number">2</span>], VAOs[<span class="number">2</span>];</span><br><span class="line">    glGenVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">    glGenBuffers(<span class="number">2</span>, VBOs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 初始化代码</span></span><br><span class="line">    <span class="comment">//// 1. 绑定顶点数组对象</span></span><br><span class="line">    <span class="comment">//glBindVertexArray(VAO);</span></span><br><span class="line">    <span class="comment">//// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ARRAY_BUFFER, VBO);</span></span><br><span class="line">    <span class="comment">//glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span><br><span class="line">    <span class="comment">//// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span></span><br><span class="line">    <span class="comment">//glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span></span><br><span class="line">    <span class="comment">//// 4. 设定顶点属性指针</span></span><br><span class="line">    <span class="comment">//glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span></span><br><span class="line">    <span class="comment">//glEnableVertexAttribArray(0);</span></span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">0</span>]);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(firstTriangle), firstTriangle, GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">1</span>]);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(secondTriangle), secondTriangle, GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">////线框模式wireframe</span></span><br><span class="line">    <span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line"></span><br><span class="line">        glUseProgram(shaderProgram);</span><br><span class="line">        <span class="comment">//glBindVertexArray(VAO);</span></span><br><span class="line">        <span class="comment">//glDrawElements(GL_TRIANGLES, 6, GL_UNSIGNED_INT, 0);</span></span><br><span class="line">        glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查触发什么事件，更新窗口状态</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放之前的分配的所有资源</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="comment">//glDeleteVertexArrays(1, &amp;VAO);</span></span><br><span class="line">    <span class="comment">//glDeleteBuffers(1, &amp;VBO);</span></span><br><span class="line">    <span class="comment">//glDeleteBuffers(1, &amp;EBO);</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">    glDeleteBuffers(<span class="number">2</span>, VBOs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回这个按键是否正在被按下</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<span class="comment">//是否按下了返回键</span></span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="创建两个着色器程序"><a href="#创建两个着色器程序" class="headerlink" title="创建两个着色器程序"></a>创建两个着色器程序</h3><p>第二个程序使用一个不同的片段着色器(顶点着色器无需改动)，再次绘制这两个三角形，让其中一个输出为黄色。结果如下：</p><p><img src="/images/posts/opengl/render_pipeline/result5.png" alt></p><p>修改着色器程序</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="comment">//const char *fragmentShaderSource = "#version 330 core\n"</span></span><br><span class="line"><span class="comment">//"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="comment">//"void main()\n"</span></span><br><span class="line"><span class="comment">//"&#123;\n"</span></span><br><span class="line"><span class="comment">//"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="comment">//"&#125;\n\0";</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShader1Source = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span> *fragmentShader2Source = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 1.0f, 0.0f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br></pre></td></tr></table></figure><p>参考源码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;glad/glad.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;GLFW/glfw3.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// settings</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_WIDTH = <span class="number">800</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">unsigned</span> <span class="keyword">int</span> SCR_HEIGHT = <span class="number">600</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* vertexShaderSource = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"layout (location = 0) in vec3 aPos;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   gl_Position = vec4(aPos.x, aPos.y, aPos.z, 1.0);\n"</span></span><br><span class="line"><span class="string">"&#125;\0"</span>;</span><br><span class="line"><span class="comment">//const char *fragmentShaderSource = "#version 330 core\n"</span></span><br><span class="line"><span class="comment">//"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="comment">//"void main()\n"</span></span><br><span class="line"><span class="comment">//"&#123;\n"</span></span><br><span class="line"><span class="comment">//"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="comment">//"&#125;\n\0";</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShader1Source = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 0.5f, 0.2f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* fragmentShader2Source = <span class="string">"#version 330 core\n"</span></span><br><span class="line"><span class="string">"out vec4 FragColor;\n"</span></span><br><span class="line"><span class="string">"void main()\n"</span></span><br><span class="line"><span class="string">"&#123;\n"</span></span><br><span class="line"><span class="string">"   FragColor = vec4(1.0f, 1.0f, 0.0f, 1.0f);\n"</span></span><br><span class="line"><span class="string">"&#125;\n\0"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 实例化GLFW窗口</span></span><br><span class="line">    glfwInit();<span class="comment">//glfw初始化</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, <span class="number">3</span>);<span class="comment">//主版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, <span class="number">3</span>);<span class="comment">//次版本号</span></span><br><span class="line">    glfwWindowHint(GLFW_OPENGL_PROFILE, GLFW_OPENGL_CORE_PROFILE);</span><br><span class="line"></span><br><span class="line">    GLFWwindow* window = glfwCreateWindow(<span class="number">800</span>, <span class="number">600</span>, <span class="string">"LearnOpenGL"</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    <span class="comment">//（宽，高，窗口名）返回一个GLFWwindow类的实例：window</span></span><br><span class="line">    <span class="keyword">if</span> (window == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to create GLFW window"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        glfwTerminate();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glfwMakeContextCurrent(window);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 告诉GLFW我们希望每当窗口调整大小的时候调用改变窗口大小的函数</span></span><br><span class="line">    glfwSetFramebufferSizeCallback(window, framebuffer_size_callback);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// glad管理opengl函数指针，初始化glad</span></span><br><span class="line">    <span class="keyword">if</span> (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 生成错误则输出错误信息</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Failed to initialize GLAD"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//build and compile 着色器程序</span></span><br><span class="line">    <span class="comment">//顶点着色器</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> vertexShader;</span><br><span class="line">    vertexShader = glCreateShader(GL_VERTEX_SHADER);</span><br><span class="line">    glShaderSource(vertexShader, <span class="number">1</span>, &amp;vertexShaderSource, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(vertexShader);</span><br><span class="line">    <span class="comment">//检查顶点着色器是否编译错误</span></span><br><span class="line">    <span class="keyword">int</span>  success;</span><br><span class="line">    <span class="keyword">char</span> infoLog[<span class="number">512</span>];</span><br><span class="line">    glGetShaderiv(vertexShader, GL_COMPILE_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success)</span><br><span class="line">    &#123;</span><br><span class="line">        glGetShaderInfoLog(vertexShader, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::VERTEX::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"vertexShader complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//片段着色器</span></span><br><span class="line">    <span class="comment">//unsigned int fragmentShader;</span></span><br><span class="line">    <span class="comment">//fragmentShader = glCreateShader(GL_FRAGMENT_SHADER);</span></span><br><span class="line">    <span class="comment">//glShaderSource(fragmentShader, 1, &amp;fragmentShaderSource, NULL);</span></span><br><span class="line">    <span class="comment">//glCompileShader(fragmentShader);</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShaderOrange;</span><br><span class="line">    fragmentShaderOrange = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> fragmentShaderYellow;</span><br><span class="line">    fragmentShaderYellow = glCreateShader(GL_FRAGMENT_SHADER);</span><br><span class="line">    glShaderSource(fragmentShaderOrange, <span class="number">1</span>, &amp;fragmentShader1Source, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShaderOrange);</span><br><span class="line">    glShaderSource(fragmentShaderYellow, <span class="number">1</span>, &amp;fragmentShader2Source, <span class="literal">NULL</span>);</span><br><span class="line">    glCompileShader(fragmentShaderYellow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    <span class="comment">//glGetShaderiv(fragmentShader, GL_LINK_STATUS, &amp;success);</span></span><br><span class="line">    <span class="comment">//if (!success) &#123;</span></span><br><span class="line">    <span class="comment">//    glGetShaderInfoLog(fragmentShader, 512, NULL, infoLog);</span></span><br><span class="line">    <span class="comment">//    std::cout &lt;&lt; "ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//else &#123;</span></span><br><span class="line">    <span class="comment">//    std::cout &lt;&lt; "fragmentShader complie SUCCESS" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    glGetShaderiv(fragmentShaderOrange, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShaderOrange, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShaderOrange complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glGetShaderiv(fragmentShaderYellow, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetShaderInfoLog(fragmentShaderYellow, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::FRAGMENT::COMPILATION_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"fragmentShaderYellow complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接着色器</span></span><br><span class="line">    <span class="comment">//unsigned int shaderProgram;</span></span><br><span class="line">    <span class="comment">//shaderProgram = glCreateProgram();</span></span><br><span class="line">    <span class="comment">//glAttachShader(shaderProgram, vertexShader);</span></span><br><span class="line">    <span class="comment">//glAttachShader(shaderProgram, fragmentShader);</span></span><br><span class="line">    <span class="comment">//glLinkProgram(shaderProgram);</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgramOrange;</span><br><span class="line">    shaderProgramOrange = glCreateProgram();</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> shaderProgramYellow;</span><br><span class="line">    shaderProgramYellow = glCreateProgram();</span><br><span class="line">    glAttachShader(shaderProgramOrange, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgramOrange, fragmentShaderOrange);</span><br><span class="line">    glLinkProgram(shaderProgramOrange);</span><br><span class="line">    glAttachShader(shaderProgramYellow, vertexShader);</span><br><span class="line">    glAttachShader(shaderProgramYellow, fragmentShaderYellow);</span><br><span class="line">    glLinkProgram(shaderProgramYellow);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//检查片段着色器是否编译错误</span></span><br><span class="line">    <span class="comment">//glGetProgramiv(shaderProgram, GL_LINK_STATUS, &amp;success);</span></span><br><span class="line">    <span class="comment">//if (!success) &#123;</span></span><br><span class="line">    <span class="comment">//    glGetProgramInfoLog(shaderProgram, 512, NULL, infoLog);</span></span><br><span class="line">    <span class="comment">//    std::cout &lt;&lt; "ERROR::SHADER::PROGRAM::LINKING_FAILED\n" &lt;&lt; infoLog &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    <span class="comment">//else &#123;</span></span><br><span class="line">    <span class="comment">//    std::cout &lt;&lt; "shaderProgram complie SUCCESS" &lt;&lt; std::endl;</span></span><br><span class="line">    <span class="comment">//&#125;</span></span><br><span class="line">    glGetProgramiv(shaderProgramOrange, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgramOrange, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgramOrange complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    glGetProgramiv(shaderProgramYellow, GL_LINK_STATUS, &amp;success);</span><br><span class="line">    <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">        glGetProgramInfoLog(shaderProgramYellow, <span class="number">512</span>, <span class="literal">NULL</span>, infoLog);</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"ERROR::SHADER::PROGRAM::LINKING_FAILED\n"</span> &lt;&lt; infoLog &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"shaderProgramYellow complie SUCCESS"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//连接后删除</span></span><br><span class="line">    glDeleteShader(vertexShader);</span><br><span class="line">    <span class="comment">//glDeleteShader(fragmentShader);</span></span><br><span class="line">    glDeleteShader(fragmentShaderOrange);</span><br><span class="line">    glDeleteShader(fragmentShaderYellow);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//顶点数据</span></span><br><span class="line">    <span class="comment">//float vertices[] = &#123;</span></span><br><span class="line">    <span class="comment">//    0.5f, 0.5f, 0.0f,   // 0号点</span></span><br><span class="line">    <span class="comment">//    0.5f, -0.5f, 0.0f,  // 1号点</span></span><br><span class="line">    <span class="comment">//    -0.5f, -0.5f, 0.0f, // 2号点</span></span><br><span class="line">    <span class="comment">//    -0.5f, 0.5f, 0.0f   // 3号点</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    <span class="comment">//unsigned int indices[] = &#123; // 注意索引从0开始!</span></span><br><span class="line">    <span class="comment">//    0, 1, 3, // 第一个三角形</span></span><br><span class="line">    <span class="comment">//    1, 2, 3  // 第二个三角形</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//float vertices[] = &#123;</span></span><br><span class="line">    <span class="comment">//    -0.9f, -0.5f, 0.0f,  // left </span></span><br><span class="line">    <span class="comment">//    -0.0f, -0.5f, 0.0f,  // right</span></span><br><span class="line">    <span class="comment">//    -0.45f, 0.5f, 0.0f,  // top </span></span><br><span class="line">    <span class="comment">//    0.9f, -0.5f, 0.0f,  // right</span></span><br><span class="line">    <span class="comment">//    0.45f, 0.5f, 0.0f   // top </span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line">    <span class="comment">//unsigned int indices[] = &#123; // 注意索引从0开始!</span></span><br><span class="line">    <span class="comment">//    0, 1, 2, // 第一个三角形</span></span><br><span class="line">    <span class="comment">//    1, 3, 4  // 第二个三角形</span></span><br><span class="line">    <span class="comment">//&#125;;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">float</span> firstTriangle[] = &#123;</span><br><span class="line">    <span class="number">-0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left </span></span><br><span class="line">    <span class="number">-0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">    <span class="number">-0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// top </span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="keyword">float</span> secondTriangle[] = &#123;</span><br><span class="line">        <span class="number">0.0f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// left</span></span><br><span class="line">        <span class="number">0.9f</span>, <span class="number">-0.5f</span>, <span class="number">0.0f</span>,  <span class="comment">// right</span></span><br><span class="line">        <span class="number">0.45f</span>, <span class="number">0.5f</span>, <span class="number">0.0f</span>   <span class="comment">// top </span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//unsigned int VBO;</span></span><br><span class="line">    <span class="comment">//glGenBuffers(1, &amp;VBO);</span></span><br><span class="line">    <span class="comment">//unsigned int VAO;</span></span><br><span class="line">    <span class="comment">//glGenVertexArrays(1, &amp;VAO);</span></span><br><span class="line">    <span class="comment">//unsigned int EBO;</span></span><br><span class="line">    <span class="comment">//glGenBuffers(1, &amp;EBO);</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">int</span> VBOs[<span class="number">2</span>], VAOs[<span class="number">2</span>];</span><br><span class="line">    glGenVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">    glGenBuffers(<span class="number">2</span>, VBOs);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//// 初始化代码</span></span><br><span class="line">    <span class="comment">//// 1. 绑定顶点数组对象</span></span><br><span class="line">    <span class="comment">//glBindVertexArray(VAO);</span></span><br><span class="line">    <span class="comment">//// 2. 把我们的顶点数组复制到一个顶点缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ARRAY_BUFFER, VBO);</span></span><br><span class="line">    <span class="comment">//glBufferData(GL_ARRAY_BUFFER, sizeof(vertices), vertices, GL_STATIC_DRAW);</span></span><br><span class="line">    <span class="comment">//// 3. 复制我们的索引数组到一个索引缓冲中，供OpenGL使用</span></span><br><span class="line">    <span class="comment">//glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, EBO);</span></span><br><span class="line">    <span class="comment">//glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indices), indices, GL_STATIC_DRAW);</span></span><br><span class="line">    <span class="comment">//// 4. 设定顶点属性指针</span></span><br><span class="line">    <span class="comment">//glVertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (void*)0);</span></span><br><span class="line">    <span class="comment">//glEnableVertexAttribArray(0);</span></span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">0</span>]);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(firstTriangle), firstTriangle, GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">    glBindBuffer(GL_ARRAY_BUFFER, VBOs[<span class="number">1</span>]);</span><br><span class="line">    glBufferData(GL_ARRAY_BUFFER, <span class="keyword">sizeof</span>(secondTriangle), secondTriangle, GL_STATIC_DRAW);</span><br><span class="line">    glVertexAttribPointer(<span class="number">0</span>, <span class="number">3</span>, GL_FLOAT, GL_FALSE, <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">float</span>), (<span class="keyword">void</span>*)<span class="number">0</span>);</span><br><span class="line">    glEnableVertexAttribArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">////线框模式wireframe</span></span><br><span class="line">    <span class="comment">//glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 渲染循环</span></span><br><span class="line">    <span class="keyword">while</span> (!glfwWindowShouldClose(window))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输入</span></span><br><span class="line">        processInput(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 渲染指令</span></span><br><span class="line">        glClearColor(<span class="number">0.2f</span>, <span class="number">0.3f</span>, <span class="number">0.3f</span>, <span class="number">1.0f</span>);</span><br><span class="line">        glClear(GL_COLOR_BUFFER_BIT);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//glUseProgram(shaderProgram);</span></span><br><span class="line">        <span class="comment">//glBindVertexArray(VAO);</span></span><br><span class="line">        <span class="comment">//glDrawArrays(GL_TRIANGLES, 0, 6);</span></span><br><span class="line"></span><br><span class="line">        glUseProgram(shaderProgramOrange);</span><br><span class="line">        glBindVertexArray(VAOs[<span class="number">0</span>]);</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        glUseProgram(shaderProgramYellow);</span><br><span class="line">        glBindVertexArray(VAOs[<span class="number">1</span>]);</span><br><span class="line">        glDrawArrays(GL_TRIANGLES, <span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line">        </span><br><span class="line">        glBindVertexArray(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查并调用事件，交换缓冲</span></span><br><span class="line">        glfwSwapBuffers(window);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查触发什么事件，更新窗口状态</span></span><br><span class="line">        glfwPollEvents();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 释放之前的分配的所有资源</span></span><br><span class="line">    glfwTerminate();</span><br><span class="line">    <span class="comment">//glDeleteVertexArrays(1, &amp;VAO);</span></span><br><span class="line">    <span class="comment">//glDeleteBuffers(1, &amp;VBO);</span></span><br><span class="line">    <span class="comment">//glDeleteBuffers(1, &amp;EBO);</span></span><br><span class="line">    glDeleteVertexArrays(<span class="number">2</span>, VAOs);</span><br><span class="line">    glDeleteBuffers(<span class="number">2</span>, VBOs);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">framebuffer_size_callback</span><span class="params">(GLFWwindow* window, <span class="keyword">int</span> width, <span class="keyword">int</span> height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 每当窗口改变大小，GLFW会调用这个函数并填充相应的参数供你处理</span></span><br><span class="line">    glViewport(<span class="number">0</span>, <span class="number">0</span>, width, height);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">processInput</span><span class="params">(GLFWwindow* window)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 返回这个按键是否正在被按下</span></span><br><span class="line">    <span class="keyword">if</span> (glfwGetKey(window, GLFW_KEY_ESCAPE) == GLFW_PRESS)<span class="comment">//是否按下了返回键</span></span><br><span class="line">        glfwSetWindowShouldClose(window, <span class="literal">true</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h4><ul><li><a href="https://learnopengl-cn.readthedocs.io/zh/latest/" target="_blank" rel="noopener">https://learnopengl-cn.readthedocs.io/zh/latest/</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在学习 OpenGL 渲染特效的东西，需要补充一些基础知识，遇到不错的介绍文章，整理摘录。&lt;/p&gt;
    
    </summary>
    
      <category term="OpenGL" scheme="https://murphypei.github.io/categories/OpenGL/"/>
    
    
      <category term="OpenGL" scheme="https://murphypei.github.io/tags/OpenGL/"/>
    
      <category term="渲染" scheme="https://murphypei.github.io/tags/%E6%B8%B2%E6%9F%93/"/>
    
      <category term="render" scheme="https://murphypei.github.io/tags/render/"/>
    
      <category term="shader" scheme="https://murphypei.github.io/tags/shader/"/>
    
  </entry>
  
  <entry>
    <title>Python.h: No such file or directory</title>
    <link href="https://murphypei.github.io//blog/2020/12/apt-error.html"/>
    <id>https://murphypei.github.io//blog/2020/12/apt-error.html</id>
    <published>2020-12-14T08:59:34.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用 pip 安装的时候遇到了一个关于 <code>Python.h</code> 和 <code>apt_pkg</code> 的错误。在我的印象中这个错误挺常见的，所以记录一下解决方案。</p><a id="more"></a><p>通过 pip 安装一些包，比如 psutil，会报一个比较常见的错误：</p><ul><li><code>psutil/_psutil_common.c:9:20: fatal error: Python.h: No such file or directory</code></li></ul><p>这个错误主要是 <code>python-dev</code> 这个包没安装到位。比如 ubuntu18.04 自带的是 python3.6。如果你安装了 python3.7，设置不到位，就会导致这个错误。常见的解决办法就是: <code>sudo apt install -fy python3.7-dev</code>。</p><p>在解决这个问题的时候发现另一个问题，<code>add-apt-repository</code> 错误：</p><ul><li><code>ModuleNotFoundError: No module named &#39;apt_pkg&#39;</code></li></ul><p>主要原因是系统默认的是 python3.5，当前运行环境中的 python3 不是 python3.5。导致一些运行时库连接错误。解决办法（python3.7 为例）：</p><p><code>sudo cp /usr/lib/python3/dist-packages/apt_pkg.cpython-35m-x86_64-linux-gnu.so /usr/lib/python3/dist-packages/apt_pkg.cpython-37m-x86_64-linux-gnu.so</code></p><p>总之上述错误多半都是由于修改了系统默认自带的 python 导致。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用 pip 安装的时候遇到了一个关于 &lt;code&gt;Python.h&lt;/code&gt; 和 &lt;code&gt;apt_pkg&lt;/code&gt; 的错误。在我的印象中这个错误挺常见的，所以记录一下解决方案。&lt;/p&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://murphypei.github.io/categories/Linux/"/>
    
    
      <category term="apt" scheme="https://murphypei.github.io/tags/apt/"/>
    
      <category term="Python.h" scheme="https://murphypei.github.io/tags/Python-h/"/>
    
      <category term="apt-pkg" scheme="https://murphypei.github.io/tags/apt-pkg/"/>
    
  </entry>
  
  <entry>
    <title>目标检测中 Anchor 与 Loss 计算的梳理</title>
    <link href="https://murphypei.github.io//blog/2020/10/anchor-loss.html"/>
    <id>https://murphypei.github.io//blog/2020/10/anchor-loss.html</id>
    <published>2020-10-19T08:59:34.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>anchor 是一类目标检测方法种的一个核心概念，其本质是一个预设的框，但是这个框也为 loss 计算带来一些麻烦。</p><a id="more"></a><p>对于一般的目标检测 loss 计算，通常分为几部分。比如 yolo 系列分为 objectness（是否包含目标）、classification（目标分类）、boundingbox-regression（目标位置）。其中，每个样本都需要计算 objectness 得分的损失，正样本需要计算 classification 和 bbox-regression 损失，其中每种损失又有不同的计算方式和组合方法，比如 bbox-regression 有 D_IoU、G_IoU、C_IoU 等等，组合方法有 Focal Loss 等等。但是这些不是我们这篇文章关注的重点。</p><p>对于目标检测我们要搞明白一个核心问题：<strong>如何生成参与 loss 计算的样本</strong>？anchor 和 ground-truth 的纠缠不休就是在这个问题上，各种框混杂一起。要搞明白这个问题，我们把带 anchor 的目标检测中出现各种框的核心概念一一剥开。</p><p>一般来说，带 anchor 的目标检测包含以下几种框：</p><ol><li>ground-truth，简称 gt，标注生成的框，包含位置信息和类别信息。</li><li>anchor，也成为先验框，尺寸预先设置好的框，一般在 feature map 上，每个像素点（也称为 cell）有多个，每个大小形状都不一样。可以通过 k-means 等方法生成适合数据集的尺寸，同时大小不同的尺寸也和模型的多个检测分支对应。</li><li>predict，也称为预测框，网络的 detect 层的输出信息，大小通常是 [n, h, w, (nc + 4 + 1)]，n 表示 feature map 上每 cell 的 anchor 数量，h 和 w 是 feature map 的大小，nc 表示类别得分，4 表示位置信息，1 表示 objectness 得分。</li></ol><p>写的越多越杂乱，所以不写太多计算，只要记住这些核心概念，下面来说明每种框之间的关联：</p><ol><li>anchor 和 gt 相互作用，通过筛选手段，确定哪个 anchor 负责预测哪个 gt，不同检测方法中筛选手段不同，并且有的规定一个 gt 必须有一个 anchor 负责预测，有的则选择忽略某些 gt，有的一个 gt 可以有多个 anchor 对应。</li><li>predict 和 anchor 一一对应。首先可以明确，每个 predict 都是对应一个 anchor 的（其实现在大部分检测方法比如 yolo，predict 输出的并不是实际坐标，需要通过 anchor 解码）。当 1 中确定某个 anchor 有负责预测 gt 之后，这个 anchor 对应的 predicts 就是正样本，其余就是负样本。predicts 的输出结果和 gt 相互作用，计算 loss。</li></ol><p>总结以上核心：<strong>正负样本通常由 gt 和先验框 anchor 匹配生成，参与计算的是 anchor 的和 gt（只有尺寸，没有类别），而计算 loss 则是其对应的 predict 和 gt（包含类别信息）</strong>。这句话就点明了 3 种框的关系，可以看出 anchor 是桥梁，非常重要。</p><p>有了以上概念，我们来实际操作解读以下经典的目标检测中一些具体实际操作。</p><h3 id="Faster-RCNN"><a href="#Faster-RCNN" class="headerlink" title="Faster-RCNN"></a>Faster-RCNN</h3><p>我的老朋友，最爱。faster-rcnn 属于 two-stage，anchor 主要是在第一层 RPN 中用到。我们知道 RPN 用于生成 RoI。我们把 RPN 网络输出的就是 predicts，那么如何计算 Loss 呢？</p><p>依据上述步骤，首先就是 anchor 和 gt 的匹配。在 faster-rcnn 中分为：</p><ol><li>初始化每个 anchor 的 mask  为 -1，-1 表示这个 anchor 被忽略，不参与 loss 计算。</li><li>计算每个 gt 和 每个 anchor 的 iou。</li><li>对于一个 anchor，如果其和所有 gt 的 iou 都小于阈值 neg_iou_thr，则标记为负样本，mask 设为 0；如果最大 iou 大于阈值 pos_iou_thr，则标记为正样本。此时有一些 gt 是没有 anchor 负责预测的，这一步的意思是挑选优质的正样本和负样本。</li><li>对于所有 gt，如果其和某个 anchor 的 iou 大于阈值 min_pos_iou，则也将这些 anchor 标记为正样本，min_pos_ios &lt;= pos_iou_thr。这一步是为了增加正样本的数量（如果不需要增加正样本数量，则可以设置只和最大 iou 的 anchor 匹配），一个 gt 可能会由多个 anchor 负责预测。通过本步骤，可以最大程度保证每个 gt 都有 anchor 负责预测，<strong>如果还是小于 min_pos_iou，那就没办法了，这个 gt 被忽略了</strong>。这一步引入的 anchor 因为 iou 较少，质量较低。</li></ol><p>上述规则将 anchor 标记分类（anchor_target_layer 实现），正样本都有对应的 gt 用于计算 bbox-regression 损失，同时正负样本本身又可以用于计算 objectness loss，直接将每个 anchor 对应的 predict 带入计算即可。没有用到的 anchor（标记为 -1），计算 loss 的时候被忽略。另外，RPN 没有 classification 损失。</p><h3 id="YOLO-V2-V3"><a href="#YOLO-V2-V3" class="headerlink" title="YOLO V2/V3"></a>YOLO V2/V3</h3><p>one-stage 最爱。废话少说，yolo v2 步骤如下：</p><ol><li>初始化，标记所有 anchor 为负样本。</li><li>对于一个 gt，确定其中心落在哪个 cell，计算该 cell 的所有 anchor 与这个 gt 的 iou，取最大值，这个 anchor 标记为正样本，负责预测该 gt。<strong>这一步计算 iou 时只考虑形状，不考虑框的位置</strong>。具体做法就是将 anchor 和 gt 这两个框的左上角对齐，然后计算 iou。这一步还隐含一个假设，多个 gt 不会落到同一个 cell 中。</li><li>如果一个 anchor 经过 1 被标记为负样本，但是其与某个 gt 的 iou 大于某个阈值（0.6），则将其标记为忽略（低质量的负样本）。这里需要注意，<strong>yolo v2/v3 中这一步计算使用的是 anchor 预测值，而不是预设的 anchor</strong>。</li></ol><p>区分了正负样本之后就可以用于计算 loss 了，类似 faster-rcnn。</p><p>我参考了这篇<a href="https://zhuanlan.zhihu.com/p/35325884" target="_blank" rel="noopener">YOLOv2原理与实现</a>，上述原理在代码中实现是倒过来的，同时在开始时还有计算 predict 和 anchor  的位置偏移，这个能够加快 predict 的形状向 anchor 的形状收敛。因为 yolo 中的 anchor 是聚合而来，本身就比较合理。仔细看下面的 loss 计算公式：</p><p><img src="/images/posts/dl/anchor/yolov2_loss.jpg" alt></p><ol><li>求和公式中 W H A 分别表示 feature map 的长、宽以及每个 cell 的 anchor 数量。</li><li>第一项是负样本，只计算 objectness 的置信度误差。</li><li>第二项是 anchor 先验框和预测框的坐标误差，只计算前 12800 个迭代，加速预测框向先验框的收敛。</li><li>第三项是正样本，其中又包含三项：<ol><li>第一项是预测框与 gt 的坐标误差（coord）；</li><li>第二项是是 objectness 置信度误差（obj）；</li><li>第三项是分类误差。</li></ol></li></ol><p>上述公式弄明白了，也就基本理解了各种框的用途和意义了。v3 和 v2 一样是基于 max iou 的匹配规则，只不过有多个检测分支，其规定一个 gt 不可能出现在多个检测分支上，也就是每个 gt 取三个检测分支上 anchor 匹配最大的那个。</p><h3 id="YOLO-V5"><a href="#YOLO-V5" class="headerlink" title="YOLO V5"></a>YOLO V5</h3><p>yolo v5 相对 v2/v3 变动很大，主要是匹配规则变了，首先明确一点，v5 和 v3 一样，同样有 3 个检测分支，但是v5 中的匹配是逐层进行的，每一层互不影响，也就是说一个 gt 可以与多个检测层的 anchor 匹配。具体规则如下（以下规则是逐层进行的）：</p><ol><li>对于一个 gt，计算其与当前层的 anchor 是否匹配，匹配是通过 shape 而不是 iou。以 h 为例，就是 gt_h/anchor_h 要大于一个 1/anchor_t，小于 anchor_t，anchor_t 默认设置为 4.0。w 同理。如果不匹配，则说明该 gt 和 anchor 匹配度不够，<strong>在当前层的检测中舍弃掉这个 gt</strong>。因此在检测小目标的 detect 层，比如下采样为 8 的 P3 层，一个大目标 gt 可能会被舍弃，认为是背景。</li><li>对于剩余 gt，计算其中心落在哪个 cell 中，同时利用四舍五入方法，找出最近的两个 cell，认为这 3 个 cell 都负责预测这个 gt。很明显，通过这种方法，正样本的数量将明显增多。<ol><li>一个 cell 相邻的有上下左右 4 个cell，根据中心点在当前 cell 中的偏移来找出和中心点比较近的两个相邻 cell。</li></ol></li></ol><p><img src="/images/posts/dl/anchor/yolov5_near_cell.jpg" alt></p><p>代码中的具体做法是：在任何一预测层，将每个 gt 复制和 anchor 个数一样多的数目（3个），然后将 gt 和 anchor 一一对应计算，去除本层不匹配的 gt，然后对 gt 原始中心点网格坐标扩展两个邻居像素，因此每个 gt 总共有 3 个 cell 上的若干个 anchor 负责预测。有个细节需要注意，前面 shape 过滤时候是不考虑 xy 坐标的，也就是说 gt 的 wh 是和所有 anchor 匹配的，会导致找到的邻居也相当于进行了 shape 过滤规则。详见 <code>build_targets</code> 函数，可以参考解析：<a href="https://zhuanlan.zhihu.com/p/183838757" target="_blank" rel="noopener">yolov5深度可视化解析</a> 。</p><p>yolo v5 的改动造成的变化主要如下：</p><ol><li>不同于 yolov3 和 v4，其 gt 可以跨层预测，即有些 gt 在多个预测层都算正样本。</li><li>不同于 yolov3 和 v4，其 gt 匹配数范围扩大，明显增加了很多正样本。（但是引入了很多低质量的负样本）</li><li>不同于 yolov3 和 v4，有些 gt 由于和 anchor 匹配度不高，而变成背景。</li></ol><p>有了正负样本，v5 的 loss 计算也很简单，classification 和 objectness confidence 分支都是 bce loss，bbox regression 直接采用 giou loss。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;anchor 是一类目标检测方法种的一个核心概念，其本质是一个预设的框，但是这个框也为 loss 计算带来一些麻烦。&lt;/p&gt;
    
    </summary>
    
      <category term="DeepLearning" scheme="https://murphypei.github.io/categories/DeepLearning/"/>
    
    
      <category term="梯度消失" scheme="https://murphypei.github.io/tags/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1/"/>
    
      <category term="ReLU" scheme="https://murphypei.github.io/tags/ReLU/"/>
    
      <category term="LeakyReLU" scheme="https://murphypei.github.io/tags/LeakyReLU/"/>
    
      <category term="激活函数" scheme="https://murphypei.github.io/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>ReLU 激活函数中神经元死亡问题</title>
    <link href="https://murphypei.github.io//blog/2020/09/relu-dying.html"/>
    <id>https://murphypei.github.io//blog/2020/09/relu-dying.html</id>
    <published>2020-09-25T08:59:34.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>最近在看 MobileNetV3 的结构特征，又碰到了新的激活函数，查看了其与 ReLU 的联系，联想到之前看到过的 ReLU 的问题，做个记录。</p><a id="more"></a><p>ReLU 激活函数可以算作是深度学习领域的 GOAT 了，虽然现在出现了很多变种和发展，但是综合使用范围和效果，其当之无愧。ReLU 之所以能获得广泛认可和应用，离不开自身的特性（图我就不画了）。</p><ol><li>单侧抑制。当输入小于 0 时，神经元处于抑制状态，也就是输出为 0。</li><li>宽阔的激活边界。当输入大于 0 时，神经元全部出于激活状态，激活值取值边界无穷大，无饱和区。<ol><li>Sigmoid 存在梯度小时问题，就是因为当出于饱和区时，导数趋近于 0，更新缓慢，拖累收敛。</li><li>另一方面，Sigmoid 这类激活函数的导数绝对值小于 1，链式法则的情况下在连乘的时候很容易迅速变小为接近于 0，也是导致梯度消失的原因。</li></ol></li><li>稀疏性。相比于 Sigmoid 之类的激活函数，稀疏性是 ReLU 的优势。Sigmoid 把抑制区设置为一个极小值，但是不为 0，因此要参与运算，而 ReLU 的抑制区的结果直接为 0，不参与后续计算，简单粗暴的造成网络稀疏性，而且计算十分简单。<ol><li>稀疏性和单侧抑制有很多生物神经学上的解释，对于大多数深度学习从业者而言，其计算简单和对网络稀疏性（防止过拟合）的优点才是真正关注的。</li></ol></li></ol><p>ReLU 凭借上述优点获得了无数青睐，但是也不能忽视其存在的不足，甚至一些不足就是由于其自身特性带来的。比如最常见的 ReLU Dying 问题。</p><p><strong>ReLU Dying 问题是指当出现异常输入时，在反向传播中会产生大的梯度，这种大的梯度会导致神经元死亡和梯度消失</strong>。等等，ReLU 不就是为了解决梯度消失的问题吗？我们提取这里的关键词，异常输入，大梯度，神经元死亡，一一解释。</p><p><img src="/images/posts/dl/relu/neural_cell.jpg" alt></p><p>上图是一个典型的神经元。</p><p>现在假设，这个神经元已经经过若干次迭代，其参数 $(\vec w, b)$ 已经迭代得趋于稳定。现在，神经元接收到了一个<strong>异常输入</strong> $\vec x$。比方说，它的某一维特征 $x_i$ 与对应的权重 $w_i$ 的乘积 $w_ix_i$ 非常大。一般来说，这意味着 $x_i$ 的绝对值非常大。于是，ReLU 的输入就会很大，对应 ReLU 的输出 $y$ 也就会很大。好了，假设这个 ReLU 神经元期望的输出（ground truth）是 $\hat y$，这个时候损失就会很大——损失一般是 $\lvert y - \hat y\rvert$ 的增函数，记为 $f\bigl(\lvert y - \hat y\rvert\bigr)$。</p><p>于是，在反向传播过程中，传递到 ReLU 的输入时的梯度就是 $g = f\bigl(\lvert y - \hat y\rvert\bigr)$ 。考虑对于偏置 $b$ 有更新：</p><script type="math/tex; mode=display">g = f\bigl(\lvert y - \hat y\rvert\bigr)</script><p>考虑到<strong>大梯度</strong> $g$ 是一个很大的正数，于是 $b$ 可能被更新为一个很小的负数。此后，对于常规输入来说，ReLU 的输入大概率是个负数。这也就是说，ReLU 大概率是关闭的。这时，梯度无法经 ReLU 反向传播至 ReLU 的输入函数。也就是说，这个神经元的参数再也不会更新了。这就是所谓的<strong>神经元死亡</strong>。</p><p>如此看来，尽管 ReLU 解决了因激活函数导数的绝对值小于 1，在反向传播连乘的过程中迅速变小消失至 0 的问题，但<strong>由于它在输入为负的区段导数恒为零，而使得它对异常值特别敏感</strong>。这种异常值可能会使 ReLU 永久关闭，而杀死神经元。</p><p>由此可见，神经网络中的梯度消失问题是个多元化的问题，不仅仅局限于由于激活函数导数连乘导致的梯度消失。</p><p>话说回来，很多激活函数比如 LeakyReLU 把小于 0 的输入的输出不设为 0，从而缓解这个问题，其实现在这个问题已经被 BN 解决了。回到上述我们分析的原因，导致 ReLU Dying 的前提是异常输入，如果 Conv-BN-ReLU 这种结构，由于 BN 的归一化操作，异常输入基本不存在了，所以这个问题也被解决了，这也是目前 ReLU 仍然流行使用的原因。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在看 MobileNetV3 的结构特征，又碰到了新的激活函数，查看了其与 ReLU 的联系，联想到之前看到过的 ReLU 的问题，做个记录。&lt;/p&gt;
    
    </summary>
    
      <category term="DeepLearning" scheme="https://murphypei.github.io/categories/DeepLearning/"/>
    
    
      <category term="梯度消失" scheme="https://murphypei.github.io/tags/%E6%A2%AF%E5%BA%A6%E6%B6%88%E5%A4%B1/"/>
    
      <category term="ReLU" scheme="https://murphypei.github.io/tags/ReLU/"/>
    
      <category term="LeakyReLU" scheme="https://murphypei.github.io/tags/LeakyReLU/"/>
    
      <category term="激活函数" scheme="https://murphypei.github.io/tags/%E6%BF%80%E6%B4%BB%E5%87%BD%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>PyTorch 多进程分布式训练实战</title>
    <link href="https://murphypei.github.io//blog/2020/09/pytorch-distributed.html"/>
    <id>https://murphypei.github.io//blog/2020/09/pytorch-distributed.html</id>
    <published>2020-09-24T08:02:34.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>PyTorch 可以通过 <code>torch.nn.DataParallel</code> 直接切分数据并行在单机多卡上，实践证明这个接口并行力度并不尽如人意，主要问题在于数据在 master 上处理然后下发到其他 slaver 上训练，而且由于 <a href="https://murphypei.github.io/blog/2017/05/python-GIL">GIL</a> 的存在只有计算是并行的。<code>torch.distributed</code> 提供了更好的接口和并行方式，搭配多进程接口 <code>torch.multiprocessing</code> 可以提供更加高效的并行训练。</p><a id="more"></a><h3 id="多进程"><a href="#多进程" class="headerlink" title="多进程"></a>多进程</h3><p>我们都知道由于 GIL 的存在， python 要想真正的并行必须使用多进程，IO 频繁可以勉强使用多线程。<code>torch.nn.DataParallel</code> 全局只有一个进程，受到了 GIL 的限制，所以肯定会拖累并行的力度。</p><p>python 自带的 <code>multiprocessing</code> 是多进程常用的实现，但是有一个巨大的问题，<strong>不支持 CUDA</strong>，所以我们使用 GPU 训练的时候不能用这个包，需要使用 PyTorch 提供的 <code>torch.multiprocessing</code>。它提供了和 <code>multiprocessing</code> 几乎一样的接口，所以用起来也比较方便。</p><p>这里额外插一句，<code>torch.distributed</code> 可以通过 <code>torch.distributed.launch</code> 启动多卡训练，但是我个人的原则是能交由自己代码控制的都不会交给工具，所以使用 <code>torch.multiprocessing</code> 手动提交多进程并行。所以本文不会对 <code>torch.distributed.launch</code> 以及多级多卡这类我没测试使用过的东西做说明。</p><h3 id="分布式训练"><a href="#分布式训练" class="headerlink" title="分布式训练"></a>分布式训练</h3><p><code>torch.distributed</code> 提供了和通用分布式系统常见的类似概念。</p><ul><li><strong>group</strong>：进程组。默认情况下，只有一个组，一个 <code>job</code> 即为一个组，也即一个 <code>world</code>，当我们使用多进程的时候，一个 <code>group</code> 就有了多个 <code>world</code>。当需要进行更加精细的通信时，可以通过 <code>new_group</code> 接口，使用 word 的子集，创建新组，用于集体通信等。</li><li><strong>world</strong>：全局进程个数。</li><li><strong>rank</strong>：表示进程序号，用于进程间通信，可以用于表示进程的优先级。我们一般设置 <code>rank=0</code> 的主机为 master 节点。</li><li><strong>local_rank</strong>：进程内 GPU 编号，非显式参数，由 <code>torch.distributed.launch</code> 内部指定。比方说， <code>rank=3</code>，<code>local_rank=0</code> 表示第 3 个进程内的第 1 块 GPU。</li></ul><h3 id="PyTorch-多进程分布式训练实战"><a href="#PyTorch-多进程分布式训练实战" class="headerlink" title="PyTorch 多进程分布式训练实战"></a>PyTorch 多进程分布式训练实战</h3><h5 id="启动多进程任务："><a href="#启动多进程任务：" class="headerlink" title="启动多进程任务："></a>启动多进程任务：</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">ngpus_per_node = torch.cuda.device_count()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> torch.cuda.is_available():</span><br><span class="line">        print(<span class="string">"\033[1;33m&#123;&#125;\033[0m"</span>.format(<span class="string">"gpu is not available, cpu will be very slow!"</span>))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(<span class="string">"Let's use &#123;&#125; GPUs!"</span>.format(torch.cuda.device_count()))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.seed <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        random.seed(args.seed)</span><br><span class="line">        torch.manual_seed(args.seed)</span><br><span class="line">        cudnn.deterministic = <span class="literal">True</span></span><br><span class="line">        print(<span class="string">"\033[1;33m&#123;&#125;\033[0m"</span>.format(</span><br><span class="line">            (<span class="string">"You have chosen to seed training. This will turn on the CUDNN deterministic setting, which can slow down "</span></span><br><span class="line">             <span class="string">"your training considerably! You may see unexpected behavior when restarting from checkpoints."</span>)))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.dist_url == <span class="string">"env://"</span> <span class="keyword">and</span> args.world_size == <span class="number">-1</span>:</span><br><span class="line">        args.world_size = int(os.environ[<span class="string">"WORLD_SIZE"</span>])</span><br><span class="line"></span><br><span class="line">    args.distributed = args.world_size &gt; <span class="number">1</span> <span class="keyword">or</span> args.multiprocessing_distributed</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.multiprocessing_distributed:</span><br><span class="line">        <span class="comment"># Since we have ngpus_per_node processes per node, the total world_size needs to be adjusted accordingly</span></span><br><span class="line">        args.world_size = ngpus_per_node * args.world_size</span><br><span class="line">        <span class="comment"># Use torch.multiprocessing.spawn to launch distributed processes: the main_worker process function</span></span><br><span class="line">        mp.spawn(main_worker, nprocs=ngpus_per_node, args=(args,))</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        main_worker(args.gpu, args)</span><br></pre></td></tr></table></figure><p>以上代码很简单，就是提交多进程任务。我们设置 <code>args.multiprocessing_distributed</code> 为 <code>True</code> 即可启动多进程分布式训练。<code>ngpus_per_node</code> 是单机上卡的数量，我们以此为标准，设置 <code>world_size</code> 也就是要启动的进程数量。然后通过 <code>torch.multiprocessing.spawn</code> 直接提交每个进程的任务。</p><p><code>args.dist_url</code> 是通信方式，<code>env://</code> 以及 <code>os.environ[&quot;WORLD_SIZE&quot;]</code> 都表示通过环境变量设置任务参数，这个不需要去纠结，不这样用就行了，通过命令行参数传入方便简单而且灵活，等你真的有大规模集群的时候再考虑通过环境配置这些参数。</p><h5 id="初始化分布式训练"><a href="#初始化分布式训练" class="headerlink" title="初始化分布式训练"></a>初始化分布式训练</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_worker</span><span class="params">(gpu, args)</span>:</span></span><br><span class="line">    args.gpu = gpu</span><br><span class="line">    <span class="keyword">if</span> args.gpu <span class="keyword">is</span> <span class="keyword">not</span> <span class="literal">None</span>:</span><br><span class="line">        print(<span class="string">"Use GPU: &#123;&#125;"</span>.format(args.gpu))</span><br><span class="line">    <span class="keyword">global</span> best_result</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> args.distributed:</span><br><span class="line">        <span class="keyword">if</span> args.dist_url == <span class="string">"env://"</span> <span class="keyword">and</span> args.rank == <span class="number">-1</span>:</span><br><span class="line">            args.rank = int(os.environ[<span class="string">"RANK"</span>])</span><br><span class="line">        <span class="keyword">if</span> args.multiprocessing_distributed:</span><br><span class="line">            <span class="comment"># For multiprocessing distributed training, rank needs to be the global rank among all the processes.</span></span><br><span class="line">            args.rank = args.rank * ngpus_per_node + args.gpu</span><br><span class="line">        torch.distributed.init_process_group(backend=args.dist_backend,</span><br><span class="line">                                             init_method=args.dist_url,</span><br><span class="line">                                             world_size=args.world_size,</span><br><span class="line">                                             rank=args.rank)</span><br></pre></td></tr></table></figure><p><code>main_worker</code> 就是每个进程实际执行的任务了，也比较好理解。这里有一个需要注意的地方：<code>torch.multiprocessing.spawn()</code> 要求提交的任务函数第一个参数是 gpu_id，并且启动多进程传参的时候不传入这个参数，是默认传入的。</p><p>这里首先设置了当前进程的 <code>rank</code>，也是通过传入的 gpu_id 设置的，也就是 GPU_0 就是 <code>rank=0</code> 了。然后最重要的就是分布式初始化了：<code>init_process_group()</code>。</p><p><code>backend</code> 参数可以参考 <a href="https://pytorch.org/docs/master/distributed.html?highlight=distributed#backends" target="_blank" rel="noopener">PyTorch Distributed Backends</a>，也就是分布式训练的底层实现，GPU 用 <code>nccl</code>，CPU 用 <code>gloo</code>，不用选了。</p><blockquote><p>这里需要注意，选择了 GPU 或者 CPU 之后，多进程通信的操作就只限于 GPU 数据和 CPU 数据了，比如 <code>nccl</code> 就不支持 CPU 数据的一些操作。</p></blockquote><p><code>init_method</code> 参数就是多进程通信的方式，前文说了通过命令行 <code>args.dist_url</code> 传入即可，单机多卡直接无脑 TCP 就行，又快又稳，比如：<code>tcp://127.0.0.1:8009</code>，随便选一个没有被占用的端口即可。</p><p><code>world_size</code> 和 <code>rank</code> 前文已经说过了。</p><p>注意，<code>main_worker</code> 函数里的每一行代码都会在每个进程上单独执行，这里可以看到，不同的进程仅仅是使用了不同的 <code>rank</code>，后续也是通过这个参数去区分不同的进程。我一般是会选择一个 master，也就是 <code>rank=0</code> 用于我的一些打印信息和其他操作。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main_worker</span><span class="params">(gpu, args)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># code...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> args.multiprocessing_distributed <span class="keyword">or</span> (args.multiprocessing_distributed <span class="keyword">and</span> args.rank % ngpus_per_node == <span class="number">0</span>):</span><br><span class="line">        args.master = <span class="literal">True</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        args.master = <span class="literal">False</span></span><br></pre></td></tr></table></figure><h4 id="训练数据处理"><a href="#训练数据处理" class="headerlink" title="训练数据处理"></a>训练数据处理</h4><p><code>torch.nn.DataParallel</code> 接口之所以说简单是因为数据是在全局进程中处理，所以不需要对 DataLoader 做特别的处理。PyTorch 分布式训练的原理是把数据直接切分成 <code>world_size</code> 份，然后在每个进程内独立处理数据、前向和反向传播，所以快。因此也必须要对 DataLoader 做一些处理，其实也是非常简单的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">if</span> torch.distributed.is_initialized():</span><br><span class="line">    train_sampler = torch.utils.data.distributed.DistributedSampler(train_dataset, shuffle=Tru)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    train_sampler = <span class="literal">None</span></span><br><span class="line"></span><br><span class="line">train_loader = torch.utils.data.DataLoader(train_dataset,</span><br><span class="line">                                            batch_size=batch_size,</span><br><span class="line">                                            shuffle=(train_sampler <span class="keyword">is</span> <span class="literal">None</span>),</span><br><span class="line">                                            num_workers=workers,</span><br><span class="line">                                            worker_init_fn=_worker_init_fn,</span><br><span class="line">                                            pin_memory=<span class="literal">True</span>,</span><br><span class="line">                                            sampler=train_sampler,</span><br><span class="line">                                            collate_fn=fast_collate)</span><br></pre></td></tr></table></figure><p>通过 <code>torch.distributed.is_initialized()</code> 我们就可以检查每个进程是否被分布式初始化了，然后直接调用 <code>torch.utils.data.distributed.DistributedSampler()</code> 实例化一个数据分发的对象，通过这个 sampler 把数据发到各个进程中。这里要特别注意一点，首先，然后使用了 <code>DistributedSampler</code>，那么 DataLoader 中的 <code>shuffle</code> 参数是无效的，这是必然的，因为数据是在最开始就直接被切分了的，每个卡在整个训练期间的时候只能看到自己的那块数据，当然，你可以设置 sampler 内部 shuffle，而且也有一个办法避免；其次，<strong>切分和 rank 无关，而且不保证连续</strong>，这是我多次实验的结论，也就是说每个卡的得到哪些数据我们完全不可控，这就是说如果你想用多卡推理，然后把推理结果和原数据顺序对应起来基本不可能，非常无语。</p><p>数据处理还有一个提示，PyTorch 文档中写的：</p><blockquote><p>In distributed mode, calling the <code>set_epoch()</code> method at the beginning of each epoch before creating the <code>DataLoader</code> iterator is necessary to make shuffling work properly across multiple epochs. Otherwise, the same ordering will be always used.</p></blockquote><p>什么意思呢？就是如果你想每个 epoch 每个卡的数据都充分 shuffle 而不是像我上面说的那样每张卡整个训练过程中只能看到自己的那部分数据，你就需要在每次迭代的过程中调用 <code>DistributedSampler.set_epoch()</code> 方法。这个就是前面提到避免每张卡只看到一部分数据的方法。我自己觉得用不用都可。</p><h4 id="多进程数据操作"><a href="#多进程数据操作" class="headerlink" title="多进程数据操作"></a>多进程数据操作</h4><p>多进程有一些麻烦事，比如打印这些，最好设置在 master 中进程，可能代码中比较多的 <code>if master</code> 了，另外一个就是我个人需求，我希望每个 epoch 能够对整个测试数据做评测，而不是 master 那自己的一部分，这个就涉及多进程间数据合并和通信了。代码为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">logits = torch.cat(logits_list, dim=<span class="number">0</span>)</span><br><span class="line">targets = torch.cat(targets_list, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For distributed parallel, collect all data and then run metrics.</span></span><br><span class="line"><span class="keyword">if</span> torch.distributed.is_initialized():</span><br><span class="line">    logits_gather_list = [torch.zeros_like(logits) <span class="keyword">for</span> _ <span class="keyword">in</span> range(ngpus_per_node)]</span><br><span class="line">    torch.distributed.all_gather(logits_gather_list, logits)</span><br><span class="line">    logits = torch.cat(logits_gather_list, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">    targets_gather_list = [torch.zeros_like(targets) <span class="keyword">for</span> _ <span class="keyword">in</span> range(ngpus_per_node)]</span><br><span class="line">    torch.distributed.all_gather(targets_gather_list, targets)</span><br><span class="line">    targets = torch.cat(targets_gather_list, dim=<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">accuracy, recall, precision, auc = classification_metrics(logits, targets)</span><br></pre></td></tr></table></figure><p><code>logits</code> 和 <code>targets</code> 是常见的分类网络的输出和标签了，如果分布式训练，则通过 <code>torch.distributed.all_gather()</code> 这个操作，将各个进程的数据都搜集到一块，然后再处理。这里的搜集方式看代码结合<a href="https://pytorch.org/docs/master/distributed.html?highlight=all_gather#torch.distributed.all_gather" target="_blank" rel="noopener">官方文档</a>就明白了，很简单。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>以上就是我自己使用 PyTorch 多进程分布式训练的经验了，没有太多原理讲解，想看其实现原理直接网上搜就行，具体怎么用看我给的代码就会了。根据我的经验，直接将这些流程嵌入到已有代码中即可，对于一些处理、打印、TensorBoard 等等都交给 master，缺点就是只能反映部分，不能反映整体，算是目前的一些不足吧。我的训练环境主要是单机多卡，写这篇文章也是结合我自己的使用经验，所以肯定有很多地方没照顾到，但是以实践为主看完这篇文章就可以上手了。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;PyTorch 可以通过 &lt;code&gt;torch.nn.DataParallel&lt;/code&gt; 直接切分数据并行在单机多卡上，实践证明这个接口并行力度并不尽如人意，主要问题在于数据在 master 上处理然后下发到其他 slaver 上训练，而且由于 &lt;a href=&quot;https://murphypei.github.io/blog/2017/05/python-GIL&quot;&gt;GIL&lt;/a&gt; 的存在只有计算是并行的。&lt;code&gt;torch.distributed&lt;/code&gt; 提供了更好的接口和并行方式，搭配多进程接口 &lt;code&gt;torch.multiprocessing&lt;/code&gt; 可以提供更加高效的并行训练。&lt;/p&gt;
    
    </summary>
    
      <category term="PyTorch" scheme="https://murphypei.github.io/categories/PyTorch/"/>
    
    
      <category term="multiprocessing" scheme="https://murphypei.github.io/tags/multiprocessing/"/>
    
      <category term="PyTorch" scheme="https://murphypei.github.io/tags/PyTorch/"/>
    
      <category term="distributed" scheme="https://murphypei.github.io/tags/distributed/"/>
    
  </entry>
  
  <entry>
    <title>机器学习中熵、交叉熵和 KL 散度的介绍</title>
    <link href="https://murphypei.github.io//blog/2020/09/entrogy-kld.html"/>
    <id>https://murphypei.github.io//blog/2020/09/entrogy-kld.html</id>
    <published>2020-09-15T02:38:59.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>我在之前的文章：<a href="https://murphypei.github.io/blog/2019/12/entropy.html">机器学习中关于熵的一些概念</a> 已经记录了机器学习中一些常见的关于熵的概念，最近看到一篇关于交叉熵和 KL 散度的英文文章，觉得不错，就大概翻译记录一下。</p><a id="more"></a><p>熵这一术语起源于统计热力学，是物理学的一个子领域。然而对于机器学习，我们更感兴趣的是信息论或香农熵定义的熵。这种熵的表述与信息的相关概念密切相关。熵是从某个随机过程产生的信息的平均速率。因此，我们首先需要解释“信息”一词在信息理论上下文中的含义。</p><h3 id="信息和概率"><a href="#信息和概率" class="headerlink" title="信息和概率"></a>信息和概率</h3><p>信息论中的信息通常是以比特为单位来衡量的，它可以被宽泛地定义为从一个给定事件中产生的“惊奇”的数量。举一个简单的例子——想象一下，我们有一个极其不公平的硬币，当抛出时，它有 99% 的机会正面着陆，而反面着陆的机会只有 1% 。我们可以使用集合符号 ${0.99, 0.01}$ 来表示。</p><p>如果我们掷硬币一次，硬币正面朝上落地，我们不会感到很惊讶，因此这种事件“传递”的信息很低。或者，如果它落在反面，我们会非常惊讶（考虑到我们对硬币的了解），因此这样一个事件的信息会很高。这在数学上可以用以下公式表示:</p><script type="math/tex; mode=display">I(E) = -log[Pr(E)] = -log(P)</script><p>这个方程给出了随机事件 E 中包含的信息：由<strong>事件概率的负对数</strong>给出的。这可以更简单地表示为 $-log(p)$。需要注意的一点是，如果我们处理的是以比特表示的信息，即每个比特不是 0 就是 1，对数的底是 2，所以 $I(E) = -log_{2}(p)$。机器学习中经常使用的一个替代单元是 <strong>nats</strong>，它适用于使用自然对数的地方。</p><p>对于我们不公平硬币的掷硬币事件，正面所包含的信息为 $-log_{2}(0.99) = 0.0144$ 位，这个值相当低，负面的信息等于 6.64 位。因此，这与上面讨论过的对信息的解释很好地吻合。</p><p>现在，回想一下熵被定义为从一个随机过程中产生的平均信息率。抛硬币过程中产生的平均或预期信息率是多少？</p><h3 id="熵和信息"><a href="#熵和信息" class="headerlink" title="熵和信息"></a>熵和信息</h3><p>我们如何计算事物的期望值或平均值？回想一下，变量 $x$ 的期望值是:</p><script type="math/tex; mode=display">E[X] = \sum_{i=1}^{n} x_{i}p_{i}</script><p>其中 $x<em>{i}$ 是 $x$ 的某个可能值，$p</em>{i}$ 是该可能值出现的概率。<strong>熵是信息的期望</strong>，因此定义为：</p><script type="math/tex; mode=display">H(X) = E[I(X)] = E[-log(P(X))] = -\sum_{i=1}^{n}P(x_{i})logP(x_{i})</script><p>同样是上述的抛硬币问题，可以很容易求解抛硬币这件事的熵：</p><script type="math/tex; mode=display">H(X) = -(0.99log(0.99) + 0.01log(0.01)) = 0.08bit</script><p>可以说，不公平硬币是一个平均信息传递率为 0.08bit 的随机信息发生器。这是相当小的，因为它被正面结果的高概率所支配。然而，应该指出的是，一枚公平的硬币会产生 1bit 的熵。以上这个例子应该能让你清楚地知道熵是什么，它测量的是什么，以及如何计算它。</p><h3 id="机器学习和熵"><a href="#机器学习和熵" class="headerlink" title="机器学习和熵"></a>机器学习和熵</h3><p>你可能想知道熵在机器学习中的应用，比如交叉熵的核心概念，你们可能已经很熟悉了，我稍后也将详细介绍。然而，熵本身也被用于机器学习。一个值得注意的和有指导意义的例子是它在强化学习的政策梯度优化中的应用。在这种情况下，训练一个神经网络来控制某个 agent，其输出由一个 softmax 层组成。这个 softmax 层是 agent 的 action 的一个概率分布，根据这个概率分布可以选择最佳 action。</p><p>比如对于一个 action 空间为 4 的强化网络，其输出结果可能为：${0.9, 0.05, 0.025, 0.025}$。在这个例子中，代理最有可能选择第一个操作（即概率为 0.9）。但熵是怎么产生的呢？强化学习中需要解决的一个关键问题是确保 agent 不会过快地学会在一组行动或策略上收敛，也就是所谓的鼓励性探索。在强化学习的政策梯度版本中，可以通过将输出层熵的负值放入损失函数来鼓励探索。因此，随着损失最小化，行为概率趋于缩小和稳定，以抵消负熵的增加。</p><blockquote><p>这一段比较难翻译，大概意思就是如果 softmax 收敛到某个结果（概率很大），则熵比较小（事件很确定，参考上述 0.99 的硬币）。而强化学习中鼓励探索性搜索，所以希望熵大一点，也就是概率分布在每个 action 上都比较平均。所以将熵的负值加入到损失函数中。这样相当于最小化损失函数时，鼓励熵增。</p></blockquote><p>比如上述的例子，如果 softmax 输出是 ${0.9, 0.05, 0.025, 0.025}$，则其在损失函数中的负熵为：-0.61。如果输出是 ${0.3, 0.2, 0.25, 0.25}$，则其在损失函数中的负熵为：-1.98，损失函数的值也因此变小，因此这也是损失函数优化的一种方向趋势。</p><p>在机器学习的某些贝叶斯方法中也使用了熵，但这里不讨论熵。现在是考虑常用交叉熵损失函数的时候了。</p><h3 id="交叉熵和-KL-散度"><a href="#交叉熵和-KL-散度" class="headerlink" title="交叉熵和 KL 散度"></a>交叉熵和 KL 散度</h3><p>交叉熵的核心是测量两个概率分布 P 和 Q 之间的“距离”。正如你所观察到的，<strong>熵本身只是一个概率分布的度量</strong>。因此如果我们试图找到一种方法来建模一个真正的概率分布 P，比如说使用一个神经网络产生一个近似的概率分布 Q，那么就需要某种可以最小化的距离或差异度量。交叉熵的差异度量来源于 Kullback-Leibler(KL) 散度。这可以从交叉熵函数的定义中看出:</p><script type="math/tex; mode=display">H(p, q) = H(p) + D_{KL}(p \parallel q)</script><p>第一个项，在优化过程中，<strong>真实概率分布 P 的熵是固定的</strong>，因此它在优化过程中是一个附加常数。在优化过程中，只有第二种近似分布的参数 Q 可以改变，因此度量两种分布距离的交叉熵的核心就是 KL 散度函数。</p><blockquote><p>这个是转换的核心，特别是对于机器学习来说，训练集的数据和标签集合就是真实概率分布，对于确定的训练集，这个概率分布是确定的，也就是在训练过程中是一个常数。所以多分类训练的时候，交叉熵损失可以用 KL 散度代替。</p></blockquote><p>从信息论的角度来看，两个分布之间的 KL 散度有许多不同的解释。简而言之，这也是一种“惊讶”的表达方式。假设 P 和 Q 很接近，如果事实证明它们并非如此，那就令人惊讶了，因此在这些情况下，KL 散度将会很大。如果它们靠得很近，那么 KL 散度就会很低。</p><blockquote><p>惊讶本质就是描述事件包含的信息。散度本质就是距离。</p></blockquote><p>从贝叶斯观点来看，KL 散度的另一种解释也是非常直观的。这种解释认为 KL 分歧是当我们从先验概率分布 Q 到后验概率分布 P 时所获得的信息。KL 散度的表达式也可以用似然比的方法推导出来。</p><blockquote><p>关于先验概率和后验概率，以及最大后验概率估计，可以参考<a href="https://murphypei.github.io/blog/2020/03/mle-map.html">最大似然估计和最大后验概率估计</a>。</p></blockquote><h4 id="贝叶斯方法推导-KL-散度"><a href="#贝叶斯方法推导-KL-散度" class="headerlink" title="贝叶斯方法推导 KL 散度"></a>贝叶斯方法推导 KL 散度</h4><p>似然比函数定义：</p><script type="math/tex; mode=display">LR = \frac{p(x)}{q(x)}</script><p>这可以解释为：如果一个值 $x$ 是从某个未知的分布中取样，似然比表示样本来自分布 P 的可能性比来自分布 Q 的可能性大多少。如果它更有可能来自 P，LR &gt; 1，否则如果它更有可能来自 Q，LR &lt; 1。</p><p>假设我们有很多独立的样本，我们想要在考虑到所有这些证据的情况下，估计出可能性函数，然后变成：</p><script type="math/tex; mode=display">LR = \prod_{i=0}^{n}\frac{p(x_{i})}{q(x_{i})}</script><p>如果我们把这个比率转换成对数，就可以把上面定义中的乘积变成一个总和：</p><script type="math/tex; mode=display">LR = \sum_{i=0}^{n}log\left(\frac{p(x_{i})}{q(x_{i})}\right)</script><p>现在我们把似然比作为总和。假设我们想要回答这样一个问题: 平均每个样本可能性, $p(x)$ 比 $q(x)$ 大多少？要做到这一点，我们可以采取的期望值的似然比，并得到：</p><script type="math/tex; mode=display">D_{KL}(P\parallel Q) = \sum_{i=0}^{n}p(x_{i})log\left(\frac{p(x_{i})}{q(x_{i})}\right)</script><p>上面的表达式就是 KL 散度的定义。它基本上是似然比的期望值。其中似然比表示的是样本数据来自分布 P 而不是分布 Q 的可能性有多大。另一种表示上述定义的方法如下(使用对数规则) :</p><script type="math/tex; mode=display">D_{KL}(P\parallel Q) = \sum_{i=0}^{n}p(x_{i})log (p(x_{i})) – \sum_{i=0}^{n}p(x_{i})log (q(x_{i}))</script><p>上述方程中的第一项是分布 P 的熵。正如你所记得的，它是 P 的信息含量的期望值。第二项是 Q 的信息量，但是通过 P 的分布加权的（而不是 Q 的分布）。如果 P 是“真实”分布，那么 KL 散度就是该分布通过 Q 表达（或称为<strong>编码</strong>）时“丢失”的信息量。</p><p>不管你怎么解释 KL 散度，它显然是概率分布 P 和 Q 之间的差值。然而它只是一个“准”距离测度，因为 $D<em>{KL}(P \parallel Q) \neq D</em>{KL}(Q \parallel P)$。</p><p>现在我们需要说明 KL 散度是如何产生交叉熵函数的。</p><h3 id="交叉熵"><a href="#交叉熵" class="headerlink" title="交叉熵"></a>交叉熵</h3><p>如前所述，交叉熵是“真实”分布 P 的熵和 P 与 Q 之间 KL 散度的组合：</p><script type="math/tex; mode=display">H(p, q) = H(p) + D_{KL}(p \parallel q)</script><p>利用熵和 KL 散度的定义，以及对数规则，我们可以得到以下交叉熵的定义:</p><script type="math/tex; mode=display">H(p, q) = – \sum_{i=0}^{n}p(x_{i})log (q(x_{i}))</script><p>在神经网络的分类任务中使用这个函数看起来像什么？在这样的任务中，我们通常要处理的真实分布 P 是一个 one-hot 编码。例如在 MNIST 手写数字分类任务中，如果图像表示手写数字“2” ，P 就是：${0, 0, 1, 0, 0, 0, 0, 0, 0, 0}$。</p><p>我们的神经网络在这样一个任务的输出层将是一个 softmax层，其中所有的输出已被规范化，所以他们的和为 1，代表一个准概率分布。这张图片的输出层 Q 可以是：${0.01, 0.02, 0.75, 0.05, 0.02, 0.1, 0.001, 0.02, 0.009, 0.02}$。</p><p>为了得到预测的类，我们将在输出上运行 $argmax$，在这个例子中，我们将得到正确的预测。然而，观察交叉熵损失函数在这种情况下是如何工作的。对于除 $i=2$ 以外的所有值，$p(x_{i})=0$，因此这些索引的总和中的值为 0。唯一没有零值的索引是 $i=2$。因此，对于 one-hot 编码向量，交叉熵折叠为:</p><script type="math/tex; mode=display">H(p,q) = -log(q(x_{i}))</script><p>在本例中，交叉熵损失为 $-log(0.75)=0.287$（使用 nats 作为信息单位）。对于 $i=2$ 指数，Q 值越接近 1，损失就越小。这是因为对于这个指标，P 和 Q 之间的 KL 散度减小了。</p><p>有人可能会问，如果交叉熵损失的分类任务降低到一个单一的输出节点计算，神经网络如何学习既增加真实索引的值，并减少所有其他节点的值？它通过节点之间通过权重进行交叉相互作用来实现这一点，通过 softmax 激活函数指数本身的性质（各项相加等于 1），如果一个单一的指数被鼓励增加，那么所有其他的指数/输出类别将被鼓励在 softmax 激活函数中减少。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;我在之前的文章：&lt;a href=&quot;https://murphypei.github.io/blog/2019/12/entropy.html&quot;&gt;机器学习中关于熵的一些概念&lt;/a&gt; 已经记录了机器学习中一些常见的关于熵的概念，最近看到一篇关于交叉熵和 KL 散度的英文文章，觉得不错，就大概翻译记录一下。&lt;/p&gt;
    
    </summary>
    
      <category term="MachineLearning" scheme="https://murphypei.github.io/categories/MachineLearning/"/>
    
    
      <category term="熵" scheme="https://murphypei.github.io/tags/%E7%86%B5/"/>
    
      <category term="KLD" scheme="https://murphypei.github.io/tags/KLD/"/>
    
      <category term="交叉熵" scheme="https://murphypei.github.io/tags/%E4%BA%A4%E5%8F%89%E7%86%B5/"/>
    
      <category term="KL 散度" scheme="https://murphypei.github.io/tags/KL-%E6%95%A3%E5%BA%A6/"/>
    
  </entry>
  
  <entry>
    <title>win10 上使用 SSH 实践</title>
    <link href="https://murphypei.github.io//blog/2020/07/win10-ssh.html"/>
    <id>https://murphypei.github.io//blog/2020/07/win10-ssh.html</id>
    <published>2020-07-27T04:24:54.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>win10 已经使用的越来越顺手，而且越发喜爱在 win10 上工作了，随手记录一下一些使用的体验和配置。</p><a id="more"></a><p>工作中使用跳板机和服务器是不可避免的，win10 中内置了 SSH 服务，可以很方便的满足我们的需求。</p><p>首先，远程 SSH 必须要有一个给力的 terminal，这里我大力推荐 windows-terminal，微软自家研发的，很有 vscode 的味道，爱不释手，目前的缺点是必须有些版本（1903以上）才能用，而且看上去比较简单，配置起来略显麻烦。关于配置，可以参考<a href="https://sspai.com/post/59380" target="_blank" rel="noopener">新生代 Windows 终端：Windows Terminal 的全面自定义</a>。</p><p>一般公司都是通过密钥登陆的，这里也比较推荐这种方式。关于密钥登录的方式以及 SSH 服务器的密钥登陆配置，可以自行查资料。不再赘述。</p><p>假设服务器已经配置了密钥登陆，那么服务器会产生一个公钥 <code>id_rsa.pub</code> 和私钥 <code>id_rsa</code>，其中公钥会写入到服务器的 <code>~/.ssh/authorized_keys</code> 中（可以添加多个公钥）。私钥就是我们用于登录服务器的。可以通过 <code>ssh -i id_rsa xxx</code> 来登录服务器。私钥和公钥是通过 <code>ssh-keygen</code> 产生的，如果产生的过程中私钥有密码，还需要输入密码。</p><p>以上登录方式每次都需要输入私钥路径，我们可以配置本地机器的 <code>~/.ssh/config</code> 来达到简化目的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Host ubuntu</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  HostName 1.1.1.1</span><br><span class="line">  Port 1111</span><br><span class="line">  User murphy</span><br></pre></td></tr></table></figure><blockquote><p>注意，这里的 <code>id_rsa</code> 是服务器上的公钥（写进 <code>~/.ssh/authorized_keys</code>）对应的私钥。</p></blockquote><p>如此处理之后，我们就可以直接通过 <code>ssh ubuntu</code> 来登录这台机器了。</p><h3 id="跳板机的处理"><a href="#跳板机的处理" class="headerlink" title="跳板机的处理"></a>跳板机的处理</h3><p>跳板机一般通过 SSH ProxyCommand 来实现直连，命令和 Linux 有一点点区别。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Host k8s006</span><br><span class="line">  IdentityFile ~/.ssh/id_rsa</span><br><span class="line">  HostName 2.2.2.2</span><br><span class="line">  User murphy</span><br><span class="line">  Port 2222</span><br><span class="line">  StrictHostKeyChecking no</span><br><span class="line">  ProxyCommand C:\Windows\System32\OpenSSH\ssh.exe ubuntu -q -X -W %h:%p</span><br></pre></td></tr></table></figure><blockquote><p>这里是以上文设置的 ubuntu 作为跳板机。</p></blockquote><p>这些需要注意的是，ProxyCommand 需要利用 <code>ssh-agent</code> 服务，这个在 windows 上是默认关闭的。我们可以将其设置为自动打开。</p><ol><li><p>检查 <code>ssh-agent</code> 服务的状态：</p><p> <code>Get-Service | select -property name,starttype</code></p><p> 在其中找到 <code>ssh-agent</code>，查看其状态，一般情况下应该是 disabled。</p></li><li><p>设置 <code>ssh-agent</code> 服务的启动方式（管理员运行）：</p><p> <code>Set-Service -Name ssh-agent -StartupType Manual</code></p><p> 这里可以是 <code>Manual</code>，也可以是 <code>Automatic</code>。</p></li><li><p>手动打开 <code>ssh-agent</code> 服务：</p><p> <code>Start-Service ssh-agent</code></p><p> 如果设置不生效，或者为 <code>Manual</code>，也可以手动打开。</p></li></ol><h3 id="保存密钥的密码"><a href="#保存密钥的密码" class="headerlink" title="保存密钥的密码"></a>保存密钥的密码</h3><p>如果产生密钥的时候设置了密码，那么每次登录的时候都需要密码，可以通过设置缓存解决。</p><p><code>ssh-add ~/.ssh/id_rsa</code>。</p><blockquote><p>这条命令也需要 <code>ssh-agent</code> 服务。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;win10 已经使用的越来越顺手，而且越发喜爱在 win10 上工作了，随手记录一下一些使用的体验和配置。&lt;/p&gt;
    
    </summary>
    
      <category term="Windows" scheme="https://murphypei.github.io/categories/Windows/"/>
    
    
      <category term="win10" scheme="https://murphypei.github.io/tags/win10/"/>
    
      <category term="SSH" scheme="https://murphypei.github.io/tags/SSH/"/>
    
      <category term="ssh-keygen" scheme="https://murphypei.github.io/tags/ssh-keygen/"/>
    
      <category term="ssh-agent" scheme="https://murphypei.github.io/tags/ssh-agent/"/>
    
      <category term="ssh-add" scheme="https://murphypei.github.io/tags/ssh-add/"/>
    
  </entry>
  
  <entry>
    <title>ResNet 原理剖析</title>
    <link href="https://murphypei.github.io//blog/2020/06/why-resnet.html"/>
    <id>https://murphypei.github.io//blog/2020/06/why-resnet.html</id>
    <published>2020-06-27T03:01:55.000Z</published>
    <updated>2021-09-06T09:24:43.040Z</updated>
    
    <content type="html"><![CDATA[<p>ResNet 算是深度学习里程碑之作了，我平时接触也比较多，写一篇文章做一些记录总结。</p><a id="more"></a><h2 id="引言：为什么会有-ResNet？"><a href="#引言：为什么会有-ResNet？" class="headerlink" title="引言：为什么会有 ResNet？"></a>引言：为什么会有 ResNet？</h2><blockquote><p>神经网络叠的越深，则学习出的效果就一定会越好吗？</p></blockquote><p>答案无疑是否定的，人们发现当模型层数增加到某种程度，模型的效果将会不升反降。也就是说，深度模型发生了<strong>退化（degradation）</strong>情况。</p><p>那么，为什么会出现这种情况？我们从以下几点来分析。</p><h3 id="过拟合（overfitting）问题"><a href="#过拟合（overfitting）问题" class="headerlink" title="过拟合（overfitting）问题"></a>过拟合（overfitting）问题</h3><p>首先看一下吴恩达机器学习公开课中所描述的过拟合问题：</p><p><img src="/images/posts/dl/resnet/andrew_ng_ml_overfitting.jpg" alt="过拟合"></p><p>在这个多项式回归问题中，左边的模型是欠拟合（underfit）的此时有很高的偏差（high bias），中间的拟合比较成功，而右边则是典型的过拟合（overfit），此时由于<strong>模型过于复杂</strong>，导致了高方差（high variance）。</p><p>然而，很明显当前CNN面临的效果退化不是因为过拟合，因为过拟合的现象是”高方差，低偏差”，即测试误差大而训练误差小。但实际上，<strong>深层CNN的训练误差和测试误差都很大</strong>。所以也不完全是过拟合的问题。</p><p><img src="/images/posts/dl/resnet/deep_model_degradation.jpg" alt="深层网络模型退化"></p><h3 id="梯度消失和爆炸（Gradient-vanishing-exploding）"><a href="#梯度消失和爆炸（Gradient-vanishing-exploding）" class="headerlink" title="梯度消失和爆炸（Gradient vanishing/exploding）"></a>梯度消失和爆炸（Gradient vanishing/exploding）</h3><p>除此之外，最受人认可的原因就是“梯度爆炸/消失（弥散）”了。为了理解什么是梯度弥散，首先回顾一下反向传播的知识。</p><p>假设我们现在需要计算一个函数：$f(x,y,z)=(x+y) \times z$ 在 $x=-2,y=5,z=-4$ 时的梯度，那么计算流程如下：</p><ol><li>前向传播计算 $f(x=-2,y=5,z=-4)$ 的结果为 -12。</li><li>令 $q=x+y$ ，可以推导反向传播：</li></ol><script type="math/tex; mode=display">\frac {df} {dz} = q = x + y = 3</script><script type="math/tex; mode=display">\frac {df} {dx} = \frac {df} {dq} \cdot \frac {dq} {dx} = z \cdot 1 = -4</script><script type="math/tex; mode=display">\frac {df} {dy} = \frac {df} {dq} \cdot \frac {dq} {dy} = z \cdot 1 = -4</script><p>上面的前向传播和反向传播学过微积分的都应该明白。反向传播其实就是输出端梯度通过链式法则向输入端传播的过程，这里假设输出端初始的梯度为 1，也就是输出端对自身求导等于 1。</p><p>观察上述反向传播，不难发现，在输出端梯度的模值，经过回传扩大了3~4倍。</p><p>这是由于反向传播结果的<strong>数值大小</strong>不止取决于求导的式子，很大程度上也取决于<strong>输入的模值。</strong>当计算图每次输入的模值都大于1，那么经过很多层回传，梯度将不可避免地呈几何倍数增长（每次都变成 3~4 倍，重复上万次，想象一下 3 的 10000 次方有多大……），直到Nan。这就是<strong>梯度爆炸</strong>现象。</p><p>当然反过来，如果我们每个阶段输入的模恒小于 1，那么梯度也将不可避免地呈几何倍数下降（比如每次都变成原来的三分之一，重复一万次就是 3 的 -10000 次方），直到 0。这就是梯度消失现象。值得一提的是，由于人为的参数设置，<strong>梯度更倾向于消失而不是爆炸</strong>。</p><p>由于至今神经网络都以反向传播为参数更新的基础，所以梯度消失问题听起来很有道理。然而，事实也并非如此，至少不止如此。</p><p>我们现在无论用 Pytorch 还是 Tensorflow，都会自然而然地加上 Bacth Normalization，<strong>而 BN 的作用本质上也是控制每层输入的模值，</strong>因此梯度的爆炸/消失现象理应在很早就被解决了（至少解决了大半）。</p><p>不是过拟合，也不是梯度消失，这就很尴尬了……CNN 没有遇到我们熟知的两个老大难问题，却还是随着模型的加深而导致效果退化。无需任何数学论证，我们都会觉得这不符合常理。</p><h3 id="为什么模型退化不符合常理？"><a href="#为什么模型退化不符合常理？" class="headerlink" title="为什么模型退化不符合常理？"></a>为什么模型退化不符合常理？</h3><p>He 在论文中举了一个例子，假设一个比较浅的网络已经可以达到不错的效果，<strong>那么即使之后堆上去的网络什么也不做，模型的效果也不会变差</strong>。而之前的深度网络出现退化问题，所以很明显什么都不做恰好是当前神经网络最难做到的东西之一。</p><blockquote><p>MobileNet V2 的论文也提到过类似的现象，由于非线性激活函数 ReLU 的存在，每次输入到输出的过程都几乎是不可逆的（信息损失）。我们很难从输出反推回完整的输入。因此 MobileNet V2 论文中选择去掉低维的 ReLU 以保留特征信息。</p></blockquote><p>我们可以认为，为了实现非线性，激活函数让特征在传播过程中丢失了信息，因此这类的神经网络都无法做到“恒等映射”。</p><p>因此，可以认为 Residual Learning 的初衷，其实是让模型的内部结构至少有恒等映射的能力。以保证在堆叠网络的过程中，网络至少不会因为继续堆叠而产生退化！</p><h2 id="深度残差学习（Deep-Residual-Learning）"><a href="#深度残差学习（Deep-Residual-Learning）" class="headerlink" title="深度残差学习（Deep Residual Learning）"></a>深度残差学习（Deep Residual Learning）</h2><h3 id="残差学习"><a href="#残差学习" class="headerlink" title="残差学习"></a>残差学习</h3><p>前面分析得出，如果深层网络后面的层都是是<strong>恒等映射</strong>，那么模型就可以转化为一个浅层网络。那现在的问题就是<strong>如何得到恒等映射</strong>了。但是要让一个神经网络你和 $H(x)=x$ 其实是非常困难的。于是 He 等人换了一个思路，把网络设计为 $H(x) = F(x) + x$，即直接把恒等映射作为网络的一部分<strong>。就可以把问题转化为</strong>学习一个残差函数 $F(x) = H(x) - x$。</p><p>只要 $F(x)=0$，就构成了一个恒等映射 $H(x) = x$。 而且，拟合残差至少比拟合恒等映射容易得多。于是，就有了 Residual block 结构。</p><p><img src="/images/posts/dl/resnet/residual_block.jpg" alt></p><p>图中右侧的曲线叫做跳接（shortcut connection），通过跳接在<strong>激活函数前，</strong>将上一层（或几层）<strong>之前的输出与本层</strong>计算的<strong>输出相加</strong>，将求和的结果输入到激活函数中做为本层的输出。</p><p>用数学语言描述，假设 Residual Block 的输入为 $x$，则输出 $y$ 等于：$y=F(x, {W_i}) + x$。$F$ 就是我们要学习的目标，即输出和输入的残差 $y-x$ 。</p><p>上图中的计算可以表示为：$F=W_2/ \sigma(W_1x)$。也就是经过两个权重层和一个激活层。这里需要注意，<strong>一个 Residual Block 必须至少含有两个权重层</strong>，否则没有意义：$y=(W_1x) + x = (W_1 + 1) + x$。相当于权重加 1，加了和没加一样。</p><p>残差网络结构根据是否改变 feature map 大小又分为两种，也就是是否 down sample（空间减半，深度翻倍）。实际实现中就是在跳接过程中是否使用卷积进行维度和空间大小的改变。</p><h3 id="What-the-question？"><a href="#What-the-question？" class="headerlink" title="What the question？"></a>What the question？</h3><p>残差学习解决了模型退化的问题，但是模型退化是一个现象问题，其本质原因或者说深度 CNN 的本质问题是什么呢？</p><p><a href="https://link.zhihu.com/?target=https%3A//arxiv.org/abs/1702.08591" target="_blank" rel="noopener">The Shattered Gradients Problem: If resnets are the answer, then what is the question?</a></p><p>论文大意是神经网络越来越深的时候，反传回来的梯度之间的相关性会越来越差，最后接近白噪声。因为我们知道图像是具备局部相关性的，那其实可以认为梯度也应该具备类似的相关性，这样更新的梯度才有意义，如果梯度接近白噪声，那梯度更新可能根本就是在做随机扰动。</p><p>论文认为即使 BN 过后梯度的模稳定在了正常范围内，但<strong>梯度的相关性实际上是随着层数增加持续衰减的</strong>。而经过证明，ResNet 可以有效减少这种相关性的衰减。大概从 $\frac {1} {2^L}$ 减小到  $\frac {1} {\sqrt(L)}$ 。这也验证了 ResNet 论文本身的观点，网络训练难度随着层数增长的速度不是线性，而至少是多项式等级的增长（如果该论文属实，则可能是指数级增长的）。</p><h2 id="后续"><a href="#后续" class="headerlink" title="后续"></a>后续</h2><p>在残差网络之后，跳接给网络的设计带来了很多新的思考。以 FPN（Feature Pyramid Network）为代表的跳接网络从语义的角度解决了深度网络的特征提取问题，那就是跳连接相加可以实现不同分辨率特征的组合，因为浅层容易有高分辨率但是低级语义的特征，而深层的特征有高级语义，但分辨率就很低了。</p><p>引入跳接实际上让模型自身<strong>有了更加“灵活”的结构</strong>，即在训练过程本身，模型可以选择在每一个部分是“更多进行卷积与非线性变换”还是“更多倾向于什么都不做”，抑或是将两者结合。模型在训练便可以自适应本身的结构。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;ResNet 算是深度学习里程碑之作了，我平时接触也比较多，写一篇文章做一些记录总结。&lt;/p&gt;
    
    </summary>
    
      <category term="DeepLearning" scheme="https://murphypei.github.io/categories/DeepLearning/"/>
    
    
      <category term="深度学习" scheme="https://murphypei.github.io/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="resnet" scheme="https://murphypei.github.io/tags/resnet/"/>
    
      <category term="残差连接" scheme="https://murphypei.github.io/tags/%E6%AE%8B%E5%B7%AE%E8%BF%9E%E6%8E%A5/"/>
    
      <category term="模型退化" scheme="https://murphypei.github.io/tags/%E6%A8%A1%E5%9E%8B%E9%80%80%E5%8C%96/"/>
    
  </entry>
  
</feed>
